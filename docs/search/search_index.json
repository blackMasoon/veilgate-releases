{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"CONTRIBUTING-DOCS/","title":"Contributing to documentation","text":"<p>This project treats the Markdown files under <code>docs/</code> as the single source of truth for product and technical documentation.</p>"},{"location":"CONTRIBUTING-DOCS/#where-to-put-things","title":"Where to put things","text":"<ul> <li><code>docs/overview/</code> \u2013 high-level product overview and positioning.</li> <li><code>docs/concepts/</code> \u2013 core concepts such as routes, upstreams, policies, admin API, MCP.</li> <li><code>docs/how-to/</code> \u2013 task-oriented guides (quickstart, securing routes, MCP, etc.).</li> <li><code>docs/reference/</code> \u2013 detailed references (configuration, admin API, MCP config, CLI).</li> </ul> <p>When adding or changing features:</p> <ol> <li>Decide which section the change belongs to.</li> <li>Add or update the relevant Markdown file(s), including frontmatter:</li> </ol> <p>```yaml</p> <p>title: Title of the page    description: One-line summary used by the docs site.</p> <p>```</p>"},{"location":"CONTRIBUTING-DOCS/#admin-api-and-generated-specs","title":"Admin API and generated specs","text":"<p>The structured definition of the admin API is generated from code, not edited by hand.</p> <ul> <li>The generator lives in <code>internal/docsgen</code>.</li> <li>The CLI entrypoint is:</li> </ul> <p><code>bash   go run ./cmd/veilgate docs export-admin-openapi \\     -out dist/docs-src/reference/admin-api.yaml \\     -version-file VERSION</code></p> <p>When adding or changing admin endpoints:</p> <ol> <li>Update the HTTP handlers in <code>internal/admin/admin.go</code>.</li> <li>Update the endpoint list in <code>internal/docsgen</code> so OpenAPI stays in sync.</li> <li>Adjust <code>docs/reference/admin-api.md</code> text if needed.</li> </ol>"},{"location":"CONTRIBUTING-DOCS/#release-and-publishing-flow","title":"Release and publishing flow","text":"<p>On release (via <code>.github/workflows/release.yml</code> + <code>scripts/release.sh</code>):</p> <ol> <li><code>scripts/release.sh</code> copies <code>docs/</code> into <code>dist/docs-src/</code> and runs the docs generator.</li> <li>The release workflow syncs <code>dist/docs-src/</code> into the <code>blackMasoon/veilgate-releases</code> repo.</li> <li>If <code>mkdocs.yml</code> exists in <code>veilgate-releases</code>, the workflow runs <code>mkdocs build</code> there.</li> </ol> <p>The MkDocs configuration and navigation live in the <code>veilgate-releases</code> repository. If you add a new page under <code>docs/</code>, remember to update the <code>mkdocs.yml</code> nav in that repo so it appears in the public documentation site.</p>"},{"location":"CONTRIBUTING-DOCS/#local-validation-optional","title":"Local validation (optional)","text":"<p>For local work you can:</p> <ul> <li>run <code>go vet ./...</code> and <code>go test ./...</code> as usual,</li> <li>run the docs generator command above to ensure OpenAPI still generates,</li> <li>run <code>mkdocs build</code> in a checkout of <code>veilgate-releases</code> to validate the full site.</li> </ul>"},{"location":"QUICKSTART/","title":"QUICKSTART","text":""},{"location":"QUICKSTART/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"QUICKSTART/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"QUICKSTART/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart.</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"QUICKSTART/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"QUICKSTART/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul>"},{"location":"QUICKSTART/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"QUICKSTART/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"QUICKSTART/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</code></p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"QUICKSTART/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"QUICKSTART/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"concepts/","title":"Core concepts","text":"<p>This section explains the core building blocks of Veilgate and how they fit together.</p> <ul> <li>Routes</li> <li>Upstreams</li> <li>Policies: auth &amp; rate limiting</li> <li>Admin API &amp; dashboard</li> <li>MCP tools</li> </ul>"},{"location":"concepts/admin-api/","title":"Admin API &amp; dashboard","text":"<p>Veilgate exposes a separate admin server for operators. It typically listens on a different port than user traffic and exposes:</p> <ul> <li>health endpoints (<code>/healthz</code>, <code>/readyz</code>),</li> <li>Prometheus metrics (<code>/metrics</code>),</li> <li>JSON admin endpoints under <code>/admin/...</code>,</li> <li>built\u2011in dashboard under <code>/dashboard</code>.</li> </ul> <p>The dashboard is a React SPA that consumes the admin JSON API to:</p> <ul> <li>display routes and their policies,</li> <li>display upstream pools and health,</li> <li>display MCP tools and their mappings (once configured),</li> <li>display summary statistics,</li> <li>manage configuration in place (when admin write access is enabled).</li> </ul>"},{"location":"concepts/admin-api/#dashboard-management-capabilities-crud","title":"Dashboard management capabilities (CRUD)","text":"<p>When the admin API is exposed with write access, the dashboard can:</p> <ul> <li>Routes</li> <li>List all effective routes (as before).</li> <li>Create new routes (<code>POST /admin/routes</code>) by filling in ID, method, host, path and upstream.</li> <li>Edit existing routes (<code>PUT /admin/routes/{id}</code>) \u2013 core routing fields can be adjusted at runtime.</li> <li>Delete routes (<code>DELETE /admin/routes/{id}</code>) \u2013 removed routes stop matching immediately.</li> <li> <p>Advanced auth and rate\u2011limit options are still primarily configured via YAML, but are validated and enforced on the updated runtime after each change.</p> </li> <li> <p>Upstreams</p> </li> <li>List upstream pools and endpoints.</li> <li>Create new upstreams (<code>POST /admin/upstreams</code>) by specifying an ID and one or more endpoint URLs.</li> <li>Edit upstream endpoints (<code>PUT /admin/upstreams/{id}</code>) \u2013 change or add/remove backend URLs.</li> <li> <p>Delete upstreams (<code>DELETE /admin/upstreams/{id}</code>); validation prevents removing upstreams still referenced by routes.</p> </li> <li> <p>API keys</p> </li> <li>View API keys defined in configuration (<code>security.api_keys</code>) as part of the policies view.</li> <li>Generate new API keys via the admin API (<code>POST /admin/security/api-keys</code>); the dashboard:<ul> <li>shows the generated key only once so it can be copied,</li> <li>updates the running configuration and key store immediately.</li> </ul> </li> <li>Activate/deactivate keys (<code>PUT /admin/security/api-keys/{id}</code>) by toggling their <code>active</code> status without removing them from history.</li> <li>Delete keys (<code>DELETE /admin/security/api-keys/{id}</code>) so they can no longer be used.</li> </ul> <p>All write operations go through the same safe flow:</p> <ol> <li>The admin server applies the change to an in\u2011memory copy of the configuration.</li> <li>The new config is validated against the same rules as the file\u2011based config.</li> <li>Runtime components (upstream registry, auth, rate limiting, router) are rebuilt.</li> <li>If everything succeeds, the new runtime is atomically swapped in; otherwise the dashboard shows a validation error and the previous config stays active.</li> </ol> <p>See the Admin API reference for endpoint\u2011level details and the write operations exposed under <code>/admin/routes</code>, <code>/admin/upstreams</code> and <code>/admin/security/api-keys</code>.</p>"},{"location":"concepts/mcp/","title":"MCP tools","text":"<p>Veilgate provides first\u2011class integration with the Model Context Protocol (MCP).</p> <p>Key ideas:</p> <ul> <li>MCP tools wrap HTTP APIs behind Veilgate and expose them to LLM agents.</li> <li>Tools have descriptors (name, description, input/output schemas).</li> <li>A tool typically maps to one or more gateway routes by ID.</li> </ul> <p>The Veilgate CLI includes scaffolding to generate an MCP server that:</p> <ul> <li>calls Veilgate via HTTP,</li> <li>uses the same auth, rate limit and observability stack as regular clients.</li> </ul> <p>See the MCP how\u2011to guides and reference for details on configuring MCP tools.</p>"},{"location":"concepts/policies/","title":"Policies: auth & rate limiting","text":"<p>title: Policies: auth &amp; rate limiting description: Built-in security and rate limiting policies and how they attach to routes.</p>"},{"location":"concepts/policies/#policies-auth-rate-limiting","title":"Policies: auth &amp; rate limiting","text":"<p>Veilgate ships with built\u2011in policies for authentication and rate limiting.</p>"},{"location":"concepts/policies/#authentication","title":"Authentication","text":"<p>Veilgate ships with two first-class authentication mechanisms that mirror the Tyk setups we are replacing:</p> <ul> <li>API keys \u2013 static keys configured in <code>security.api_keys</code>. A single,   configurable header carries keys across all routes   (<code>security.api_keys_header_name</code>, default <code>X-API-Key</code>). When a particular API   needs to honor a legacy header (<code>Api-key</code>, <code>X-Customer-Key</code>, etc.), override   it per route via <code>routes[].auth.api_key_header_name</code>. The dashboard now   surfaces both the global default and per-route overrides so operators can   confirm exactly what the gateway expects.</li> <li>JWT \u2013 tokens issued by configurable providers. Veilgate supports HS256,   RS256 with a local PEM, and RS256 via JWKS discovery. JWKS issuers declare a   <code>jwks_url</code> and a positive <code>jwks_cache_ttl_seconds</code>; the gateway fetches and   caches keys, selecting the right one via the token's <code>kid</code>. Optional <code>issuer</code>   and <code>audience[]</code> claims are validated for every token.</li> </ul> <p>Policies can be attached to routes to enforce:</p> <ul> <li>specific key sets or header names,</li> <li>specific JWT issuers/audiences or downstream claim constraints.</li> </ul>"},{"location":"concepts/policies/#rate-limiting","title":"Rate limiting","text":"<p>Rate limiting is implemented as an efficient in\u2011memory token bucket.</p> <p>Limits can be configured per:</p> <ul> <li>API key (consumer),</li> <li>client IP,</li> <li>route.</li> </ul> <p>Policy configuration lives in the <code>rate_limit</code> section and is attached to routes via references.</p>"},{"location":"concepts/routes/","title":"Routes","text":"<p>Routes describe how Veilgate matches incoming HTTP requests and where they should be forwarded.</p> <p>Each route can match on:</p> <ul> <li>Host \u2013 HTTP <code>Host</code> header.</li> <li>Path \u2013 path prefix or pattern.</li> <li>Method \u2013 HTTP method such as <code>GET</code>, <code>POST</code>.</li> <li>Optional predicates \u2013 headers or query parameters.</li> </ul> <p>Matched routes are compiled into a Route Runtime which holds:</p> <ul> <li>upstream pool reference,</li> <li>middleware pipeline (auth, rate limiting, transforms),</li> <li>metadata (route ID, name, tags) used for metrics and observability.</li> </ul> <p>See the configuration reference for the exact YAML structure of routes.</p>"},{"location":"concepts/upstreams/","title":"Upstreams","text":"<p>Upstreams represent backend services that Veilgate proxies traffic to.</p> <p>Key ideas:</p> <ul> <li>Upstream pools \u2013 named sets of endpoints (hosts) with load\u2011balancing strategy.</li> <li>Health \u2013 each endpoint can be marked as up, degraded or down based on active/passive checks.</li> <li>Connection management \u2013 Veilgate uses tuned HTTP transports for connection pooling and timeouts.</li> </ul> <p>Routes reference upstream pools by ID, so you can:</p> <ul> <li>reuse upstreams across many routes,</li> <li>change upstream details without touching route definitions.</li> </ul>"},{"location":"how-to/","title":"How\u2011to guides","text":"<p>Start here for practical, task\u2011oriented guides:</p> <ul> <li>Quickstart: Docker + docker-compose</li> <li>Dashboard guide</li> <li>Migrating from Tyk</li> <li>(Planned) Securing routes with API keys and JWT</li> <li>(Planned) Rate limiting common scenarios</li> <li>(Planned) Exposing an API as an MCP tool</li> </ul>"},{"location":"how-to/dashboard-guide/","title":"Dashboard guide","text":"<p>The Veilgate dashboard provides a web-based interface for monitoring gateway health, managing routes, and configuring security policies.</p>"},{"location":"how-to/dashboard-guide/#accessing-the-dashboard","title":"Accessing the dashboard","text":"<p>The dashboard is served by the admin server (default port 9090):</p> <pre><code>http://localhost:9090/dashboard\n</code></pre> <p>If admin authentication is configured, you'll be prompted to log in first.</p>"},{"location":"how-to/dashboard-guide/#overview-page","title":"Overview page","text":"<p>The Overview page displays:</p> <ul> <li>Gateway status: Health and readiness indicators</li> <li>Quick stats: Total routes, upstreams, and active API keys</li> <li>Top routes: Routes with the most traffic</li> <li>Top API keys: Most active API keys by request count</li> </ul> <p>This page auto-refreshes to show current statistics.</p>"},{"location":"how-to/dashboard-guide/#routes-view","title":"Routes view","text":"<p>The Routes view allows you to manage all gateway routes.</p>"},{"location":"how-to/dashboard-guide/#viewing-routes","title":"Viewing routes","text":"<p>The routes table displays:</p> Column Description ID Unique route identifier Method HTTP method(s) matched Host Optional host matcher Path URL path pattern Upstream Target backend pool Auth Authentication requirements Rate Limit Rate limiting configuration Features Active features (CORS, cache, rewrite, etc.)"},{"location":"how-to/dashboard-guide/#creating-a-route","title":"Creating a route","text":"<ol> <li>Click Add route</li> <li>Fill in the required fields:</li> <li>ID: Unique identifier (e.g., <code>orders-api-v2</code>)</li> <li>Method: HTTP method or <code>*</code> for all</li> <li>Path: URL pattern (e.g., <code>/api/v1/*</code>)</li> <li>Upstream ID: Target backend pool</li> <li>Configure optional features:</li> <li>Rewrite: Path prefix stripping/adding</li> <li>CORS: Cross-origin settings</li> <li>Response Headers: Add/remove headers</li> <li>Cache: Response caching</li> <li>Proxy: Host and TLS options</li> <li>IP Filter: CIDR-based access control</li> <li>Click Create route</li> </ol>"},{"location":"how-to/dashboard-guide/#editing-a-route","title":"Editing a route","text":"<ol> <li>Click Edit next to the route</li> <li>Modify the desired fields</li> <li>Click Save changes</li> </ol> <p>Note: Route ID cannot be changed after creation.</p>"},{"location":"how-to/dashboard-guide/#deleting-a-route","title":"Deleting a route","text":"<ol> <li>Click Delete next to the route</li> <li>Confirm the deletion</li> </ol> <p>Warning: Deletion is immediate and cannot be undone.</p>"},{"location":"how-to/dashboard-guide/#route-features","title":"Route features","text":"<p>The Features column shows pills for active features:</p> <ul> <li>rewrite: Path rewriting is configured</li> <li>CORS: Cross-origin requests enabled</li> <li>headers: Response header manipulation</li> <li>cache: Response caching enabled</li> <li>proxy: Custom proxy settings</li> <li>IP filter: IP-based access control</li> </ul>"},{"location":"how-to/dashboard-guide/#upstreams-view","title":"Upstreams view","text":"<p>Manage backend server pools in the Upstreams view.</p>"},{"location":"how-to/dashboard-guide/#viewing-upstreams","title":"Viewing upstreams","text":"<p>The table shows:</p> Column Description ID Unique upstream identifier Endpoints Backend server URLs"},{"location":"how-to/dashboard-guide/#creating-an-upstream","title":"Creating an upstream","text":"<ol> <li>Click Add upstream</li> <li>Enter the ID</li> <li>Add endpoint URLs (one per line)</li> <li>Click Create upstream</li> </ol>"},{"location":"how-to/dashboard-guide/#editing-an-upstream","title":"Editing an upstream","text":"<ol> <li>Click Edit next to the upstream</li> <li>Modify endpoint URLs</li> <li>Click Save changes</li> </ol>"},{"location":"how-to/dashboard-guide/#deleting-an-upstream","title":"Deleting an upstream","text":"<ol> <li>Click Delete next to the upstream</li> <li>Confirm the deletion</li> </ol> <p>Note: You cannot delete an upstream that is referenced by routes.</p>"},{"location":"how-to/dashboard-guide/#policies-view","title":"Policies view","text":"<p>The Policies view shows security configuration and allows API key management.</p>"},{"location":"how-to/dashboard-guide/#api-keys-section","title":"API Keys section","text":"<p>Displays configured API keys with:</p> <ul> <li>ID and label</li> <li>Active/inactive status</li> <li>Default header name (global setting)</li> </ul>"},{"location":"how-to/dashboard-guide/#jwt-issuers-section","title":"JWT Issuers section","text":"<p>Shows configured JWT providers:</p> <ul> <li>Issuer ID and URL</li> <li>Algorithm (HS256, RS256, JWKS)</li> <li>Audience constraints</li> <li>JWKS URL and cache TTL (for JWKS)</li> </ul>"},{"location":"how-to/dashboard-guide/#managing-api-keys","title":"Managing API keys","text":""},{"location":"how-to/dashboard-guide/#generating-a-new-key","title":"Generating a new key","text":"<ol> <li>Optionally enter a Label</li> <li>Click Generate API key</li> <li>Copy the key immediately \u2013 it won't be shown again</li> </ol>"},{"location":"how-to/dashboard-guide/#activatingdeactivating-keys","title":"Activating/Deactivating keys","text":"<ol> <li>Find the key in the table</li> <li>Click Activate or Deactivate</li> </ol>"},{"location":"how-to/dashboard-guide/#deleting-keys","title":"Deleting keys","text":"<ol> <li>Click Delete next to the key</li> <li>Confirm the deletion</li> </ol>"},{"location":"how-to/dashboard-guide/#mcp-tools-view","title":"MCP Tools view","text":"<p>Manage Model Context Protocol (MCP) tool definitions.</p>"},{"location":"how-to/dashboard-guide/#current-tools","title":"Current tools","text":"<p>Lists configured MCP tools with:</p> <ul> <li>Name and description</li> <li>Linked route ID</li> <li>HTTP method and path</li> </ul>"},{"location":"how-to/dashboard-guide/#design-tools","title":"Design tools","text":"<p>Generate MCP tool configurations:</p> <ol> <li>Select routes to expose as tools</li> <li>Add descriptions</li> <li>Export configuration snippet</li> </ol>"},{"location":"how-to/dashboard-guide/#export-mcp-server","title":"Export MCP server","text":"<p>Generate a complete MCP server project:</p> <ol> <li>Select tools to include</li> <li>Configure server metadata</li> <li>Download as ZIP</li> </ol>"},{"location":"how-to/dashboard-guide/#security-metrics-view","title":"Security Metrics view","text":"<p>Monitor authentication and rate limiting events.</p>"},{"location":"how-to/dashboard-guide/#auth-failures","title":"Auth failures","text":"<p>Shows authentication failure counts by:</p> <ul> <li>Route ID</li> <li>Failure reason (API key, JWT, etc.)</li> </ul>"},{"location":"how-to/dashboard-guide/#rate-limit-rejections","title":"Rate limit rejections","text":"<p>Displays rate limiting events by:</p> <ul> <li>Route ID</li> <li>Scope (IP, API key, route)</li> </ul>"},{"location":"how-to/dashboard-guide/#dashboard-authentication","title":"Dashboard authentication","text":"<p>When <code>admin_auth</code> is configured, the dashboard requires login.</p>"},{"location":"how-to/dashboard-guide/#logging-in","title":"Logging in","text":"<ol> <li>Navigate to <code>/dashboard</code></li> <li>Enter username and password</li> <li>Click Login</li> </ol> <p>The session is stored in an HTTP-only cookie.</p>"},{"location":"how-to/dashboard-guide/#logging-out","title":"Logging out","text":"<ol> <li>Click Logout in the navigation</li> <li>Confirm logout</li> </ol>"},{"location":"how-to/dashboard-guide/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"Key Action <code>r</code> Refresh current view <code>h</code> Go to Overview <code>?</code> Show help"},{"location":"how-to/dashboard-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/dashboard-guide/#dashboard-not-loading","title":"Dashboard not loading","text":"<ol> <li>Check that the admin server is running on the correct port</li> <li>Verify no firewall rules blocking access</li> <li>Check browser console for errors</li> </ol>"},{"location":"how-to/dashboard-guide/#login-issues","title":"Login issues","text":"<ol> <li>Verify admin credentials are configured</li> <li>Check that cookies are enabled</li> <li>Try clearing browser cookies</li> </ol>"},{"location":"how-to/dashboard-guide/#data-not-updating","title":"Data not updating","text":"<ol> <li>Click refresh or press <code>r</code></li> <li>Check gateway health status</li> <li>Verify admin API is responding</li> </ol>"},{"location":"how-to/dashboard-guide/#cors-errors-in-browser","title":"CORS errors in browser","text":"<p>The dashboard makes requests to the admin API on the same origin. If you're running the dashboard from a different origin:</p> <ol> <li>Configure CORS on the admin server</li> <li>Or access via the same origin</li> </ol>"},{"location":"how-to/dashboard-guide/#api-access","title":"API access","text":"<p>All dashboard functionality is backed by the admin JSON API. You can use these endpoints directly for automation:</p> <pre><code># List routes\ncurl http://localhost:9090/admin/routes\n\n# Create route\ncurl -X POST http://localhost:9090/admin/routes \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\":\"new-route\",\"path\":\"/new/*\",\"method\":\"*\",\"upstream_id\":\"backend\"}'\n\n# Get statistics\ncurl http://localhost:9090/admin/stats/routes\n</code></pre> <p>See the Admin API reference for complete documentation.</p>"},{"location":"how-to/migrating-from-tyk/","title":"Migrating from Tyk","text":"<p>This guide helps you migrate existing Tyk Gateway configurations to Veilgate, covering the automated migration tool and manual configuration adjustments.</p>"},{"location":"how-to/migrating-from-tyk/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to your Tyk API definition files (<code>apis/*.json</code>)</li> <li>Optional: CORS configuration files (<code>config/cors-*.json</code>)</li> <li>Go 1.21+ installed (for running the migration tool)</li> <li>Understanding of your current Tyk setup</li> </ul>"},{"location":"how-to/migrating-from-tyk/#quick-migration","title":"Quick migration","text":""},{"location":"how-to/migrating-from-tyk/#step-1-run-the-migration-tool","title":"Step 1: Run the migration tool","text":"<p>Veilgate includes an automated migration tool that converts Tyk API definitions to Veilgate format:</p> <pre><code># From the Veilgate repository root\ngo run ./scripts/tyk-to-veilgate/convert.go \\\n  -apis=/path/to/tyk/apis \\\n  -cors=/path/to/tyk/config \\\n  -output=./veilgate.yaml\n</code></pre> <p>The tool outputs warnings for features that require manual attention.</p>"},{"location":"how-to/migrating-from-tyk/#step-2-review-the-generated-configuration","title":"Step 2: Review the generated configuration","text":"<p>Open the generated <code>veilgate.yaml</code> and verify:</p> <ul> <li>Routes: Ensure paths and methods match your expectations</li> <li>Upstreams: Verify backend URLs are correct</li> <li>Authentication: Configure secrets for API keys and JWT issuers</li> <li>Rate limits: Adjust values based on your traffic patterns</li> </ul>"},{"location":"how-to/migrating-from-tyk/#step-3-add-secrets","title":"Step 3: Add secrets","text":"<p>The migration tool does not copy secrets. Add them manually:</p> <pre><code>security:\n  api_keys:\n    - id: mobile-app\n      key: \"your-secret-key-here\"\n      label: \"Mobile Application\"\n  jwt_issuers:\n    - id: main-idp\n      algorithm: JWKS\n      jwks_url: \"https://auth.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#step-4-test-the-configuration","title":"Step 4: Test the configuration","text":"<pre><code># Validate the configuration\n./veilgate validate-config -config=./veilgate.yaml\n\n# Start in development mode\n./veilgate serve -config=./veilgate.yaml\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#feature-mapping-reference","title":"Feature mapping reference","text":""},{"location":"how-to/migrating-from-tyk/#listen_path-and-strip_listen_path","title":"listen_path and strip_listen_path","text":"<p>Tyk:</p> <pre><code>{\n  \"proxy\": {\n    \"listen_path\": \"/ext/orders/\",\n    \"strip_listen_path\": true,\n    \"target_url\": \"http://orders:8080/api/v1\"\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: orders\n    path: /ext/orders/*\n    upstream_id: orders-upstream\n    rewrite:\n      strip_prefix: /ext/orders\n      add_prefix: /api/v1\n\nupstreams:\n  - id: orders-upstream\n    endpoints:\n      - url: http://orders:8080\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#cors-configuration","title":"CORS configuration","text":"<p>Tyk (inline):</p> <pre><code>{\n  \"CORS\": {\n    \"enable\": true,\n    \"allowed_origins\": [\"https://app.example.com\"],\n    \"allowed_methods\": [\"GET\", \"POST\"],\n    \"allowed_headers\": [\"*\"],\n    \"allow_credentials\": true,\n    \"max_age\": 24\n  }\n}\n</code></pre> <p>Tyk (separate file <code>config/cors-orders.json</code>):</p> <pre><code>{\n  \"enable\": true,\n  \"allowed_origins\": [\"https://app.example.com\"]\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: orders\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n      allowed_methods:\n        - GET\n        - POST\n      allowed_headers:\n        - \"*\"\n      allow_credentials: true\n      max_age: 24\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#response-headers","title":"Response headers","text":"<p>Tyk:</p> <pre><code>{\n  \"global_response_headers\": {\n    \"Strict-Transport-Security\": \"max-age=31536000\",\n    \"X-Content-Type-Options\": \"nosniff\"\n  },\n  \"global_response_headers_remove\": [\"Server\", \"X-Powered-By\"]\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: api\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000\"\n        X-Content-Type-Options: nosniff\n      remove:\n        - Server\n        - X-Powered-By\n</code></pre> <p>For global headers, use <code>server.response_headers</code>:</p> <pre><code>server:\n  response_headers:\n    add:\n      Strict-Transport-Security: \"max-age=31536000\"\n    remove:\n      - Server\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#jwt-authentication-jwks","title":"JWT authentication (JWKS)","text":"<p>Tyk:</p> <pre><code>{\n  \"use_keyless_access\": false,\n  \"jwt_signing_method\": \"RSA\",\n  \"jwt_source\": \"https://auth.example.com/.well-known/jwks.json\",\n  \"jwt_identity_base_field\": \"sub\"\n}\n</code></pre> <p>Veilgate:</p> <pre><code>security:\n  jwt_issuers:\n    - id: main-idp\n      algorithm: JWKS\n      jwks_url: https://auth.example.com/.well-known/jwks.json\n      jwks_cache_ttl_seconds: 300\n      audience:\n        - your-app\n\nroutes:\n  - id: protected-api\n    auth:\n      jwt_issuer_id: main-idp\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#api-key-authentication","title":"API key authentication","text":"<p>Tyk:</p> <pre><code>{\n  \"use_standard_auth\": true,\n  \"auth\": {\n    \"auth_header_name\": \"Api-key\"\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: service-a\n      key: \"secret-key\"\n\nroutes:\n  - id: internal-api\n    auth:\n      api_key: true\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#rate-limiting","title":"Rate limiting","text":"<p>Tyk:</p> <pre><code>{\n  \"disable_rate_limit\": false,\n  \"global_rate_limit\": {\n    \"rate\": 1000,\n    \"per\": 60\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: api\n    rate_limit:\n      enabled: true\n      requests_per_second: 16.67  # 1000/60\n      burst: 50\n      scope: ip\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#proxy-options","title":"Proxy options","text":"<p>Tyk:</p> <pre><code>{\n  \"proxy\": {\n    \"preserve_host_header\": true,\n    \"transport\": {\n      \"ssl_insecure_skip_verify\": true\n    }\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: legacy-api\n    proxy:\n      preserve_host_header: true\n      tls:\n        insecure_skip_verify: true\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#features-not-supported","title":"Features not supported","text":"<p>The following Tyk features are not available in Veilgate:</p> Feature Alternative Go plugins Move logic to external services JSVM virtual endpoints Use dedicated microservices GraphQL schemas Use a dedicated GraphQL gateway Quota policies Use external quota management OAuth2 token generation Use a dedicated identity provider Custom middleware chains Use Veilgate's built-in middleware"},{"location":"how-to/migrating-from-tyk/#dashboard-migration","title":"Dashboard migration","text":"<p>After migrating your API definitions, use the Veilgate dashboard to:</p> <ol> <li>View routes: Navigate to Routes view to see all migrated routes</li> <li>Edit configurations: Use the route editor for CORS, headers, and caching</li> <li>Manage API keys: Generate and manage keys in the Policies view</li> <li>Monitor traffic: Check statistics in the Overview and route details</li> </ol> <p>Access the dashboard at <code>http://localhost:9090/dashboard</code> (admin port).</p>"},{"location":"how-to/migrating-from-tyk/#testing-the-migration","title":"Testing the migration","text":""},{"location":"how-to/migrating-from-tyk/#health-checks","title":"Health checks","text":"<pre><code># Check gateway health\ncurl http://localhost:8080/healthz\n\n# Check admin health\ncurl http://localhost:9090/healthz\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#verify-routes","title":"Verify routes","text":"<pre><code># List all routes via admin API\ncurl http://localhost:9090/admin/routes | jq\n\n# Test a specific endpoint\ncurl -H \"Api-key: your-key\" http://localhost:8080/ext/orders/\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#compare-responses","title":"Compare responses","text":"<p>Test equivalent requests against both Tyk and Veilgate to verify behavior:</p> <pre><code># Against Tyk\ncurl -v https://tyk-gateway/ext/orders/123\n\n# Against Veilgate\ncurl -v http://localhost:8080/ext/orders/123\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#rollback-plan","title":"Rollback plan","text":"<p>If issues arise, you can run Tyk and Veilgate in parallel:</p> <ol> <li>Keep Tyk running on its original ports</li> <li>Run Veilgate on different ports (e.g., 8081, 9091)</li> <li>Use a load balancer to gradually shift traffic</li> <li>Monitor error rates and latency</li> <li>Complete migration once confident</li> </ol>"},{"location":"how-to/migrating-from-tyk/#getting-help","title":"Getting help","text":"<ul> <li>Review the configuration reference</li> <li>Check the admin API documentation</li> <li>Open an issue on GitHub for specific migration challenges</li> </ul>"},{"location":"how-to/quickstart-docker-compose/","title":"Quickstart \u2013 Docker + docker-compose","text":""},{"location":"how-to/quickstart-docker-compose/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"how-to/quickstart-docker-compose/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart (bundled in the release).</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>security.api_keys_header_name</code> \u2013 global header carrying API keys   (defaults to <code>X-API-Key</code>, but you can switch to <code>Api-key</code> to match legacy Tyk clients),</li> <li><code>security.jwt_issuers</code> \u2013 JWT providers; set <code>algorithm: JWKS</code> and a <code>jwks_url</code>   when you want Veilgate to discover RS256 signing keys automatically,</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul> <p>For example, to mirror the Tyk setup where clients send <code>Api-key</code> and JWTs come from an IdP that exposes JWKS metadata:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: demo\n      key: demo-secret-key\n  jwt_issuers:\n    - id: accounts\n      issuer: \"https://id.example.com/\"\n      audience: [\"mobile-app\"]\n      algorithm: JWKS\n      jwks_url: \"https://id.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre> <p>Every route with <code>auth.api_key: true</code> now expects <code>Api-key: demo-secret-key</code>. Routes referencing the <code>accounts</code> issuer validate RS256 tokens by downloading and caching signing keys from the JWKS URL. See the configuration reference for the complete set of fields and validation rules.</p>"},{"location":"how-to/quickstart-docker-compose/#adding-an-mcp-server-to-the-demo-stack","title":"Adding an MCP server to the demo stack","text":"<p>Once you have designed MCP tools in the dashboard (MCP Tools \u2192 Design tools), you can export a ready-to-run MCP server as a ZIP archive:</p> <ol> <li>Open MCP Tools in the dashboard and ensure you have at least one MCP    tool configured (for example, for the demo <code>items</code> API).</li> <li>Switch to the Export MCP server tab.</li> <li>Choose the tools to include, set a server name (e.g. <code>items-api-mcp</code>) and    download the ZIP.</li> <li>Unpack the ZIP next to your <code>docker-compose.yml</code> or in a separate repo and    build the MCP server:</li> </ol> <pre><code>unzip items-api-mcp.zip -d ./items-api-mcp\ncd items-api-mcp/mcp/items-api-mcp\ngo build ./...\n</code></pre> <p>You can now run the MCP server alongside Veilgate (for example using a separate Dockerfile and service in <code>docker-compose.yml</code>) and configure your MCP-compatible client to talk to this new binary while all HTTP traffic still flows through Veilgate.</p>"},{"location":"how-to/quickstart-docker-compose/#initial-admin-user-dashboard-login","title":"Initial admin user &amp; dashboard login","text":"<p>To use the built\u2011in dashboard for managing routes, upstreams and API keys, you need an admin user. There are two recommended ways to bootstrap it:</p> <ol> <li>Via configuration file (hash only, no plaintext):</li> </ol> <p>In <code>config/veilgate.yaml</code> add:</p> <p><code>yaml    admin_auth:      store_path: ./data/admin-users.db         # optional, default: ./data/admin-users.db      seed_admin_user: admin                    # user name      seed_admin_password_hash: \"&lt;bcrypt-hash&gt;\" # bcrypt hash of the initial password</code></p> <p>On first start, if no admin users exist yet, Veilgate creates this user and    stores it in a small embedded database at <code>store_path</code>.</p> <ol> <li>Via environment variables (convenient for local/docker\u2011compose dev):</li> </ol> <p>Instead of hard\u2011coding the password hash in YAML, you can seed the first    admin user from environment variables. For example, in your    <code>docker-compose.yml</code>:</p> <p><code>yaml    services:      veilgate:        environment:          VEILGATE_DEV_ADMIN_USER: admin          VEILGATE_DEV_ADMIN_PASSWORD: admin          VEILGATE_ADMIN_SESSION_SECRET: \"change-me-long-random\"</code></p> <p>On first start, if the admin store is empty:</p> <ul> <li><code>VEILGATE_DEV_ADMIN_USER</code> and <code>VEILGATE_DEV_ADMIN_PASSWORD</code> are used to      create an <code>admin</code> user,</li> <li>the password is hashed with bcrypt at startup; only the hash is stored      on disk.</li> </ul> <p>After bootstrapping, visit <code>http://localhost:9090/dashboard</code> and log in with the admin credentials you configured above.</p>"},{"location":"how-to/quickstart-docker-compose/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"how-to/quickstart-docker-compose/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p>```bash curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</p>"},{"location":"how-to/quickstart-docker-compose/#or-if-you-switched-to-api-key","title":"\u2026or, if you switched to Api-key:","text":"<p>curl -H 'Api-key: demo-secret-key' http://localhost:8080/    ```</p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"how-to/quickstart-docker-compose/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"how-to/quickstart-docker-compose/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"overview/","title":"Veilgate \u2013 overview","text":"<p>Veilgate is a single-binary, high\u2011performance HTTP API gateway with:</p> <ul> <li>Gateway \u2013 configurable reverse proxy with routing, auth, rate limiting and DDoS guardrails.</li> <li>Admin server &amp; dashboard \u2013 JSON admin API plus a built\u2011in React dashboard for operators.</li> <li>MCP integration \u2013 first\u2011class support for exposing HTTP APIs as MCP tools for LLM agents.</li> </ul> <p>Veilgate focuses on:</p> <ul> <li>Performance \u2013 low additional latency vs talking directly to upstreams.</li> <li>Simplicity \u2013 configuration\u2011first, minimal moving parts.</li> <li>Extensibility \u2013 composable middleware, policies and MCP tools.</li> <li>Operability \u2013 metrics, health checks, rich admin API and dashboard.</li> </ul> <p>For a deeper architectural walkthrough, see:</p> <ul> <li>Core concepts</li> <li>How\u2011to guides</li> <li>Reference</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section contains detailed reference material:</p> <ul> <li>Configuration reference \u2013 structure of <code>veilgate.yaml</code>.</li> <li>Admin API \u2013 OpenAPI-backed reference for the admin server.</li> <li>MCP configuration \u2013 how to define MCP tools and mappings.</li> <li>CLI commands \u2013 <code>veilgate</code> commands and flags.</li> <li>Performance \u2013 benchmarking and performance tuning guide.</li> <li>Changelog &amp; Conventional Commits \u2013 how changelog generation and commit conventions work.</li> </ul>"},{"location":"reference/admin-api/","title":"Admin API","text":"<p>The admin server exposes a JSON API for operators under a dedicated listener.</p> <p>Endpoints include:</p> <ul> <li><code>GET /healthz</code> \u2013 basic liveness probe.</li> <li><code>GET /readyz</code> \u2013 readiness probe.</li> <li><code>GET /metrics</code> \u2013 Prometheus metrics.</li> <li><code>POST /admin/auth/login</code> \u2013 authenticate an admin user and establish a session (HTTP-only cookie).</li> <li><code>POST /admin/auth/logout</code> \u2013 terminate the current admin session.</li> <li><code>GET /admin/routes</code> \u2013 effective routes and their configuration.</li> <li><code>POST /admin/routes</code> \u2013 create a new route and apply it at runtime.</li> <li><code>PUT /admin/routes/{id}</code> \u2013 update an existing route.</li> <li><code>DELETE /admin/routes/{id}</code> \u2013 delete an existing route.</li> <li><code>GET /admin/upstreams</code> \u2013 upstream pools and health.</li> <li><code>GET /admin/policies</code> \u2013 auth and rate\u2011limit policies.</li> <li><code>GET /admin/mcp/tools</code> \u2013 MCP tools and mappings (once configured).</li> <li><code>GET /admin/summary</code> \u2013 basic gateway summary (total routes and upstreams).</li> <li><code>GET /admin/stats/routes</code> \u2013 basic usage statistics per route (requests, errors, latency).</li> <li><code>GET /admin/stats/api-keys</code> \u2013 basic usage statistics per API key.</li> <li><code>GET /admin/stats/security</code> \u2013 aggregated auth failures and rate-limit rejections per route.</li> </ul> <p>The full, structured definition of the admin API is generated as an OpenAPI document and published in the external documentation site.</p> <p>Most <code>/admin/*</code> endpoints (including the dashboard under <code>/dashboard</code>) require a valid admin session and are rate-limited per client IP to protect against abuse. Errors are returned as JSON objects of the form:</p> <pre><code>{ \"error\": \"human readable message\" }\n</code></pre>"},{"location":"reference/changelog/","title":"Changelog &amp; Conventional Commits","text":"<p>Veilgate uses an automated changelog generated from git history using the Conventional Commits convention. The CI release workflow reads commits between versions and updates <code>CHANGELOG.md</code> and GitHub Releases automatically.</p>"},{"location":"reference/changelog/#conventional-commits-in-veilgate","title":"Conventional Commits in Veilgate","text":"<p>Commit messages SHOULD follow this shape:</p> <pre><code>type(scope): short description\n</code></pre> <p>Where:</p> <ul> <li><code>type</code> is one of:</li> <li><code>feat</code> \u2013 new user-facing feature.</li> <li><code>fix</code> \u2013 bug fix.</li> <li><code>perf</code> \u2013 performance improvements.</li> <li><code>refactor</code> \u2013 internal refactors that are not features or fixes.</li> <li><code>docs</code> \u2013 documentation-only changes.</li> <li><code>test</code> \u2013 tests only.</li> <li><code>build</code> \u2013 build tooling, dependencies.</li> <li><code>ci</code> \u2013 CI configuration, workflows.</li> <li><code>chore</code> \u2013 maintenance, small internal tweaks.</li> <li><code>revert</code> \u2013 reverting a previous commit.</li> <li><code>scope</code> is optional and indicates the main area, e.g. <code>router</code>, <code>admin-api</code>,   <code>dashboard</code>, <code>mcp</code>, <code>release</code>, <code>docs</code>.</li> </ul> <p>Examples:</p> <pre><code>feat(router): add host-based routing support\nfix(ratelimit): avoid nil dereference when config is missing\ndocs: describe MCP tools in configuration reference\nci(release): make checkout fetch full history\n</code></pre>"},{"location":"reference/changelog/#breaking-changes","title":"Breaking changes","text":"<p>Breaking changes SHOULD be marked using one of:</p> <ul> <li>A <code>!</code> after the type or scope:</li> </ul> <p><code>text   feat!: remove deprecated gateway flags   refactor(router)!: change default path matching semantics</code></p> <ul> <li>Or a <code>BREAKING CHANGE:</code> footer in the commit body:</li> </ul> <p>```text   feat(auth): switch default JWT algorithm to RS256</p> <p>BREAKING CHANGE: HS256 tokens are no longer accepted by default; config must be updated.   ```</p> <p>The changelog generator detects <code>!</code> and <code>BREAKING CHANGE:</code> and highlights these entries accordingly.</p>"},{"location":"reference/changelog/#release-commits","title":"Release commits","text":"<p>Release/version bump commits use a dedicated form so they are easy to exclude from the changelog:</p> <pre><code>chore(release): vX.Y.Z\n</code></pre> <p>These commits are created automatically by the GitHub Actions release workflow and SHOULD NOT be authored manually.</p>"},{"location":"reference/changelog/#how-the-changelog-is-generated","title":"How the changelog is generated","text":"<ul> <li>The CI workflow <code>.github/workflows/release.yml</code>:</li> <li>Bumps the <code>VERSION</code> file on pushes to <code>main</code>.</li> <li>Runs <code>scripts/gen-changelog.sh</code> to:<ul> <li>Read commits between the previous tag (e.g. <code>v0.1.7</code>) and <code>HEAD</code>.</li> <li>Group them into sections like Added, Fixed, Changed,   Performance, Docs, Tests, CI, Internal.</li> <li>Prepend a new <code>## [vX.Y.Z] - YYYY-MM-DD</code> section to <code>CHANGELOG.md</code>.</li> </ul> </li> <li> <p>Extracts the section for the current version and uses it as the body     of the GitHub Release.</p> </li> <li> <p><code>CHANGELOG.md</code> is therefore single source of truth for release notes   and is auto-generated. Manual edits will be overwritten.</p> </li> </ul>"},{"location":"reference/changelog/#local-preview","title":"Local preview","text":"<p>You can preview what the next changelog section will look like without modifying <code>CHANGELOG.md</code>:</p> <pre><code>scripts/gen-changelog.sh --from v0.1.7 --to HEAD --version 0.1.8 --preview\n</code></pre> <ul> <li><code>--from</code> should usually be the last released tag (<code>vX.Y.Z</code>).</li> <li><code>--to</code> is typically <code>HEAD</code>.</li> <li><code>--version</code> is the upcoming version number (without the leading <code>v</code>).</li> </ul> <p>This command prints the generated section to stdout instead of writing it into <code>CHANGELOG.md</code>.</p>"},{"location":"reference/cli/","title":"CLI reference","text":"<p>The <code>veilgate</code> binary exposes several subcommands:</p> <ul> <li><code>veilgate serve</code> \u2013 start the gateway and admin servers.</li> <li><code>veilgate validate-config</code> \u2013 validate the configuration file and exit.</li> <li><code>veilgate mcp init</code> \u2013 scaffold a new MCP server backed by Veilgate.</li> </ul> <p>This section will be extended as additional commands and flags are added, including the documentation export command used by the docs pipeline.</p>"},{"location":"reference/configuration/","title":"Configuration reference","text":"<p>Veilgate is configured using a YAML file, typically named <code>veilgate.yaml</code>.</p> <p>High\u2011level sections include:</p> <ul> <li><code>server</code> \u2013 listener addresses, timeouts, connection limits.</li> <li><code>admin</code> \u2013 admin/metrics/dashboard listener.</li> <li><code>logging</code> \u2013 log level, format and outputs.</li> <li><code>metrics</code> \u2013 Prometheus metrics settings.</li> <li><code>upstreams</code> \u2013 upstream pools and their endpoints.</li> <li><code>routes</code> \u2013 route matchers, policies and upstream references.</li> <li><code>security</code> \u2013 API keys, JWT issuers and related options.</li> <li><code>rate_limit</code> \u2013 rate limit policies and defaults.</li> <li><code>mcp</code> \u2013 MCP tool definitions and mappings (once configured).</li> <li><code>admin_auth</code> \u2013 admin users, sessions and admin API rate\u2011limits.</li> </ul> <p>See example configs under <code>examples/</code> and in release packages for concrete values.</p>"},{"location":"reference/configuration/#logging-request-correlation-ids","title":"Logging \u2013 request &amp; correlation IDs","text":"<p>Veilgate automatically ensures every incoming request carries a <code>request_id</code> for consistent debugging:</p> <ul> <li>Incoming <code>X-Request-ID</code> headers are respected; if missing, the gateway   generates a new opaque ID and returns it via the same header.</li> <li><code>X-Correlation-ID</code> headers are copied through unchanged so upstream systems   can stitch together multi-hop traces.</li> <li>Both values are stored in the request context and emitted with every structured   log entry (<code>request_id</code>, <code>correlation_id</code> fields), making it easy to filter   logs per call chain.</li> </ul> <p>Set <code>logging.access.enabled: false</code> to completely remove the access-log middleware from the hot path in high-throughput environments (fewer allocations, no per-request JSON log). When disabled, request/correlation IDs are not attached to the context, so only enable this mode if you prefer raw performance over diagnostic richness. Customise formats and levels via the rest of the <code>logging</code> section as before.</p>"},{"location":"reference/configuration/#metrics-auth-rate-limit-counters","title":"Metrics \u2013 auth &amp; rate-limit counters","text":"<p>In addition to the core HTTP metrics, Veilgate now exports dedicated security counters whenever <code>metrics</code> are enabled:</p> <ul> <li><code>veilgate_auth_failures_total{route_id,reason}</code> counts API key and JWT   failures. <code>reason</code> is either <code>api_key</code>, <code>jwt</code>, or <code>unknown</code>.</li> <li><code>veilgate_ratelimit_rejections_total{route_id,scope}</code> counts requests rejected   by rate limiting. <code>scope</code> reflects the evaluated limiter (<code>ip</code>, <code>route</code>,   <code>api_key</code>, or <code>unknown</code> when not set).</li> </ul> <p>Use these series to alert on unexpected auth errors or aggressive clients. The associated <code>/admin/stats/*</code> snapshots can be disabled via <code>metrics.detailed_stats: false</code>, which removes per-request lock contention for the in-memory counters while leaving Prometheus metrics untouched. This is recommended for latency-sensitive production or benchmark profiles.</p>"},{"location":"reference/configuration/#admin_auth-admin-users-dashboard-login","title":"<code>admin_auth</code> \u2013 admin users &amp; dashboard login","text":"<p>The optional <code>admin_auth</code> section controls how admin users are stored and how the dashboard <code>/dashboard</code> and admin API <code>/admin/*</code> are protected.</p> <p>Example:</p> <pre><code>admin_auth:\n  store_path: ./data/admin-users.db\n  seed_admin_user: admin\n  seed_admin_password_hash: \"&lt;bcrypt-hash&gt;\"\n  # or, to read plaintext from an env var and hash it at startup:\n  # seed_admin_password_env: VEILGATE_ADMIN_BOOTSTRAP_PASSWORD\n  rate_limit:\n    enabled: true\n    requests_per_second: 10\n    burst: 20\n</code></pre> <p>Key fields:</p> <ul> <li><code>store_path</code> \u2013 path to the embedded admin user database (bbolt file). If not   set, a sensible default under the process working directory is used.</li> <li><code>seed_admin_user</code> / <code>seed_admin_password_hash</code> \u2013 optional initial admin   credentials; the password must be provided as a bcrypt hash.</li> <li><code>seed_admin_password_env</code> \u2013 optional name of an environment variable holding   the plaintext password to be hashed at startup (convenient for dev/test).</li> <li><code>rate_limit</code> \u2013 basic rate limit settings for the admin API (same shape as   <code>rate_limit.default</code> used for routes).</li> </ul>"},{"location":"reference/configuration/#security-api-keys-jwt-issuers","title":"<code>security</code> \u2013 API keys &amp; JWT issuers","text":"<p>The <code>security</code> section configures shared authentication primitives that routes can reference later on:</p> <ul> <li><code>api_keys</code> \u2013 static keys defined up front (id, key, optional label/created_at).</li> <li><code>api_keys_header_name</code> \u2013 global header that carries API keys on every route.   Defaults to <code>X-API-Key</code>, but you can switch to Tyks <code>Api-key</code> or any other   canonical header without recompiling the gateway.</li> <li><code>jwt_issuers</code> \u2013 trusted JWT providers. Each issuer advertises:</li> <li><code>id</code> \u2013 unique reference used by routes (<code>routes[].auth.jwt_issuer_id</code>).</li> <li><code>algorithm</code> \u2013 <code>HS256</code>, <code>RS256</code> (local PEM), or <code>JWKS</code> for remote key sets.</li> <li>Depending on the algorithm, additional fields such as <code>hs256_secret</code>,     <code>rsa_public_key_path</code>, <code>jwks_url</code>, and <code>jwks_cache_ttl_seconds</code> are required.</li> <li>Optional <code>issuer</code> and <code>audience[]</code> constraints are enforced during token     validation.</li> </ul> <p>Routes can still override the header name on a per-route basis via <code>routes[].auth.api_key_header_name</code>. If left empty, the global header name applies.</p> <p>Example:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: m2m-service\n      key: demo-secret-key\n      label: \"Internal service\"\n  jwt_issuers:\n    - id: accounts\n      issuer: \"https://id.example.com/\"\n      audience: [\"truckmanager\"]\n      algorithm: JWKS\n      jwks_url: \"https://id.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre> <p>In the example above every route that enables <code>auth.api_key: true</code> expects the client to send <code>Api-key: demo-secret-key</code>. Any route that references the <code>accounts</code> issuer validates RS256 tokens by discovering signing keys from the JWKS URL and caching them for five minutes.</p>"},{"location":"reference/configuration/#routescache-http-response-caching","title":"<code>routes[].cache</code> \u2013 HTTP response caching","text":"<p>Veilgate provides a simple in-memory cache for idempotent requests (GET/HEAD) to reduce upstream load and improve latency. Configure caching per route:</p> <pre><code>routes:\n  - id: cached-api\n    path: /api/v1/products\n    method: GET\n    upstream_id: products-svc\n    cache:\n      enable: true\n      ttl_seconds: 300\n      vary_by_headers:\n        - Accept-Language\n        - Accept-Encoding\n      cache_all_safe_requests: false\n      honor_upstream_cache_control: true\n</code></pre> <p>Key fields:</p> <ul> <li><code>enable</code> \u2013 must be <code>true</code> to activate caching for the route.</li> <li><code>ttl_seconds</code> \u2013 how long cached responses remain valid (default is route TTL).</li> <li><code>vary_by_headers</code> \u2013 list of request headers to include in the cache key   (e.g., <code>Accept-Language</code> produces separate cache entries per language).</li> <li><code>cache_all_safe_requests</code> \u2013 when <code>true</code>, also caches OPTIONS requests.</li> <li><code>honor_upstream_cache_control</code> \u2013 when <code>true</code>, respects <code>Cache-Control: no-store</code>,   <code>Cache-Control: private</code>, and <code>max-age</code> directives from upstream responses.</li> </ul> <p>Cache metrics are exposed via Prometheus: - <code>veilgate_cache_events_total{route_id,event}</code> where <code>event</code> is <code>hit</code>, <code>miss</code>,   or <code>store</code>.</p>"},{"location":"reference/configuration/#routesproxy-proxy-and-transport-options","title":"<code>routes[].proxy</code> \u2013 Proxy and transport options","text":"<p>Each route can customize how requests are proxied to upstreams:</p> <pre><code>routes:\n  - id: legacy-api\n    path: /legacy/*\n    method: \"*\"\n    upstream_id: legacy-backend\n    proxy:\n      preserve_host_header: true\n      tls:\n        insecure_skip_verify: true\n      timeouts:\n        dial_seconds: 5\n        tls_handshake_seconds: 5\n        response_header_seconds: 30\n        expect_continue_seconds: 1\n</code></pre> <p>Key fields:</p> <ul> <li><code>preserve_host_header</code> \u2013 when <code>true</code>, the original <code>Host</code> header from the   client request is passed to the upstream (instead of the upstream's hostname).   Useful for virtual-host routing on legacy backends.</li> <li><code>tls.insecure_skip_verify</code> \u2013 skip TLS certificate verification for upstream   connections. Use only for development or trusted internal services.</li> <li><code>timeouts.dial_seconds</code> \u2013 TCP dial timeout to upstream.</li> <li><code>timeouts.tls_handshake_seconds</code> \u2013 TLS handshake timeout.</li> <li><code>timeouts.response_header_seconds</code> \u2013 time to wait for response headers.</li> <li><code>timeouts.expect_continue_seconds</code> \u2013 time to wait for 100 Continue response.</li> </ul> <p>The same <code>proxy</code> block can be specified at the upstream level (<code>upstreams[].proxy</code>) to set defaults for all routes using that upstream. Route-level settings override upstream-level settings.</p>"},{"location":"reference/configuration/#serverhttp-global-http-client-tuning","title":"<code>server.http</code> \u2013 Global HTTP client tuning","text":"<p>Global transport settings for all upstream connections:</p> <pre><code>server:\n  http:\n    max_idle_conns: 512\n    max_idle_conns_per_host: 128\n    idle_conn_timeout_seconds: 90\n    dial_timeout_seconds: 30\n    tls_handshake_timeout_seconds: 10\n    response_header_timeout_seconds: 30\n    expect_continue_timeout_seconds: 1\n</code></pre> <p>These defaults apply to all upstreams unless overridden by <code>upstreams[].proxy</code> or <code>routes[].proxy</code>.</p>"},{"location":"reference/configuration/#routesrewrite-path-rewriting","title":"<code>routes[].rewrite</code> \u2013 Path rewriting","text":"<p>Control how request paths are transformed before proxying:</p> <pre><code>routes:\n  - id: api-v2\n    path: /ext/api/v2/*\n    method: GET\n    upstream_id: api-backend\n    rewrite:\n      strip_prefix: /ext\n      add_prefix: /internal\n</code></pre> <ul> <li><code>strip_prefix</code> \u2013 removes the specified prefix from the request path before   forwarding. The prefix must match the beginning of the configured route path.</li> <li><code>add_prefix</code> \u2013 prepends the specified prefix to the (possibly stripped) path.</li> </ul> <p>Example transformation: <code>/ext/api/v2/users</code> \u2192 <code>/internal/api/v2/users</code></p>"},{"location":"reference/configuration/#routesresponse_headers-response-header-manipulation","title":"<code>routes[].response_headers</code> \u2013 Response header manipulation","text":"<p>Add or remove headers from responses:</p> <pre><code>routes:\n  - id: secure-api\n    path: /api/*\n    method: \"*\"\n    upstream_id: backend\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000; includeSubDomains\"\n        X-Content-Type-Options: nosniff\n        X-Frame-Options: DENY\n      remove:\n        - Server\n        - X-Powered-By\n</code></pre> <p>Global response headers can be configured under <code>server.response_headers</code> and are applied before route-specific overrides.</p>"},{"location":"reference/configuration/#metricssink-stats-export-pump-alternative","title":"<code>metrics.sink</code> \u2013 Stats export (Pump alternative)","text":"<p>Export periodic stats snapshots to external stores. Currently supports JSONL file output as a lightweight alternative to Tyk Pump:</p> <pre><code>metrics:\n  enabled: true\n  sink:\n    jsonl:\n      path: /var/log/veilgate/stats.jsonl\n      interval_seconds: 60\n</code></pre> <p>Each snapshot includes: - <code>timestamp</code> \u2013 when the snapshot was taken. - <code>route_stats</code> \u2013 per-route request counts and latency. - <code>api_key_stats</code> \u2013 per-API-key usage statistics. - <code>auth_failures</code> \u2013 authentication failure counts by route and reason. - <code>rate_limit_rejections</code> \u2013 rate limit rejection counts by route and scope.</p> <p>The JSONL format (one JSON object per line) is suitable for log aggregation tools like Loki, Elasticsearch, or custom processing pipelines.</p>"},{"location":"reference/configuration/#routesip_filter-ip-based-access-control","title":"<code>routes[].ip_filter</code> \u2013 IP-based access control","text":"<p>Configure CIDR-based allow/deny lists for fine-grained IP filtering per route:</p> <pre><code>routes:\n  - id: admin-api\n    path: /admin/*\n    method: \"*\"\n    upstream_id: admin-backend\n    ip_filter:\n      allow_cidrs:\n        - 10.0.0.0/8\n        - 192.168.1.0/24\n        - 172.16.0.0/12\n      deny_cidrs:\n        - 0.0.0.0/0\n</code></pre> <p>Key fields:</p> <ul> <li><code>allow_cidrs</code> \u2013 list of CIDR ranges that are allowed to access this route.   If specified, only IPs matching these ranges can access the route.</li> <li><code>deny_cidrs</code> \u2013 list of CIDR ranges that are explicitly denied. Deny rules   are evaluated after allow rules.</li> </ul> <p>Evaluation order:</p> <ol> <li>If <code>allow_cidrs</code> is non-empty, the client IP must match at least one allowed CIDR.</li> <li>If <code>deny_cidrs</code> is non-empty and the client IP matches any denied CIDR, access is denied.</li> <li>If neither list is configured, all IPs are allowed.</li> </ol> <p>The middleware extracts the client IP from: 1. The first IP in the <code>X-Forwarded-For</code> header (if present) 2. The remote address from the connection</p>"},{"location":"reference/configuration/#routescors-cors-configuration","title":"<code>routes[].cors</code> \u2013 CORS configuration","text":"<p>Enable Cross-Origin Resource Sharing (CORS) for browser-based API access:</p> <pre><code>routes:\n  - id: public-api\n    path: /api/v1/*\n    method: \"*\"\n    upstream_id: api-backend\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n        - https://staging.example.com\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - OPTIONS\n      allowed_headers:\n        - Content-Type\n        - Authorization\n        - X-Requested-With\n      allow_credentials: true\n      max_age: 24\n</code></pre> <p>Key fields:</p> <ul> <li><code>enable</code> \u2013 must be <code>true</code> to activate CORS handling for the route.</li> <li><code>allowed_origins</code> \u2013 list of origins that are allowed to make cross-origin requests.   Use <code>*</code> for wildcard (not recommended with credentials).</li> <li><code>allowed_methods</code> \u2013 HTTP methods permitted in cross-origin requests.</li> <li><code>allowed_headers</code> \u2013 request headers that clients may include in cross-origin requests.</li> <li><code>allow_credentials</code> \u2013 whether to include credentials (cookies, auth headers) in requests.   Note: <code>allow_credentials: true</code> is incompatible with wildcard origins.</li> <li><code>max_age</code> \u2013 how long (in hours) browsers should cache preflight responses.</li> </ul> <p>Preflight handling:</p> <p>When CORS is enabled, Veilgate automatically handles <code>OPTIONS</code> preflight requests by responding with appropriate <code>Access-Control-*</code> headers without forwarding to the upstream. This reduces upstream load and improves response times.</p>"},{"location":"reference/configuration/#complete-route-configuration-example","title":"Complete route configuration example","text":"<p>Here's a complete example showing all available route options:</p> <pre><code>routes:\n  - id: orders-api-v2\n    host: api.example.com\n    path: /ext/orders/v2/*\n    method: \"*\"\n    upstream_id: orders-backend\n\n    # Path rewriting\n    rewrite:\n      strip_prefix: /ext/orders/v2\n      add_prefix: /api/orders\n\n    # CORS for browser access\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n      allowed_headers:\n        - \"*\"\n      allow_credentials: false\n      max_age: 24\n\n    # Security headers\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000; includeSubDomains\"\n        X-Content-Type-Options: nosniff\n        X-Frame-Options: DENY\n        Referrer-Policy: strict-origin-when-cross-origin\n      remove:\n        - Server\n        - X-Powered-By\n\n    # Response caching\n    cache:\n      enable: true\n      ttl_seconds: 300\n      vary_by_headers:\n        - Accept-Language\n      honor_upstream_cache_control: true\n\n    # Proxy options\n    proxy:\n      preserve_host_header: false\n      tls:\n        insecure_skip_verify: false\n      timeouts:\n        dial_seconds: 5\n        response_header_seconds: 30\n\n    # IP filtering\n    ip_filter:\n      allow_cidrs:\n        - 10.0.0.0/8\n\n    # Authentication\n    auth:\n      api_key: true\n      jwt_issuer_id: main-idp\n\n    # Rate limiting\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      scope: api_key\n</code></pre>"},{"location":"reference/mcp/","title":"MCP configuration","text":"<p>MCP (Model Context Protocol) support in Veilgate is driven by configuration.</p> <p>At a high level, MCP configuration describes:</p> <ul> <li>tools exposed to LLM agents,</li> <li>mappings from tools to gateway routes / HTTP endpoints,</li> <li>JSON schemas for tool inputs and outputs.</li> </ul>"},{"location":"reference/mcp/#mcp-section-in-gatewayconfig","title":"MCP section in <code>GatewayConfig</code>","text":"<p>MCP tools are configured under the top-level <code>mcp</code> section of <code>GatewayConfig</code>.</p> <p>Each tool is represented by a flat structure that intentionally mirrors Veilgate routes instead of introducing a separate policy system.</p>"},{"location":"reference/mcp/#schema","title":"Schema","text":"<p>In Go types (see <code>internal/config/types.go</code>):</p> <pre><code>type MCPConfig struct {\n    Tools []MCPToolSpec `yaml:\"tools,omitempty\" json:\"tools,omitempty\"`\n}\n\ntype MCPToolSpec struct {\n    Name        string `yaml:\"name\" json:\"name\"`\n    Description string `yaml:\"description,omitempty\" json:\"description,omitempty\"`\n    RouteID     string `yaml:\"route_id,omitempty\" json:\"route_id,omitempty\"`\n    Method      string `yaml:\"method,omitempty\" json:\"method,omitempty\"`\n    Path        string `yaml:\"path,omitempty\" json:\"path,omitempty\"`\n}\n</code></pre> <ul> <li><code>name</code> \u2013 required, MCP tool identifier (must be unique across tools),</li> <li><code>description</code> \u2013 optional, human-readable description,</li> <li><code>route_id</code> \u2013 optional link to an existing <code>routes[].id</code> in <code>GatewayConfig</code>,</li> <li><code>method</code> \u2013 optional HTTP method (e.g. <code>GET</code>, <code>POST</code>),</li> <li><code>path</code> \u2013 optional HTTP path (e.g. <code>/users/{id}</code>).</li> </ul> <p>Validation rules (see <code>internal/config/validate.go</code>):</p> <ul> <li>every tool must have <code>name</code>,</li> <li>tool names must be unique,</li> <li>if <code>route_id</code> is provided, it must point at a route defined in <code>routes</code>.</li> </ul>"},{"location":"reference/mcp/#minimal-example","title":"Minimal example","text":"<pre><code>server:\n  listen_address: \"0.0.0.0:8080\"\nadmin:\n  listen_address: \"0.0.0.0:9090\"\nlogging:\n  level: \"info\"\nmetrics:\n  enabled: true\n\nupstreams:\n  - id: \"example-api\"\n    endpoints:\n      - url: \"http://example.com\"\n\nroutes:\n  - id: \"example-route\"\n    path: \"/example\"\n    method: \"GET\"\n    upstream_id: \"example-api\"\n\nmcp:\n  tools:\n    - name: \"example_route_tool\"\n      description: \"Call the /example route via Veilgate.\"\n      route_id: \"example-route\"\n      method: \"GET\"\n      path: \"/example\"\n</code></pre> <p>This configuration defines a single MCP tool <code>example_route_tool</code> which is logically coupled to the <code>example-route</code> route.</p>"},{"location":"reference/mcp/#admin-api-adminmcptools","title":"Admin API: <code>/admin/mcp/tools</code>","text":"<p>The admin API exposes the current MCP tools and supports basic CRUD via:</p> <pre><code>GET /admin/mcp/tools\nPOST /admin/mcp/tools\nPUT  /admin/mcp/tools/{name}\nDELETE /admin/mcp/tools/{name}\n</code></pre> <p><code>GET /admin/mcp/tools</code> returns a JSON array of objects matching <code>MCPToolSpec</code>:</p> <pre><code>[\n  {\n    \"name\": \"example_route_tool\",\n    \"description\": \"Call the /example route via Veilgate.\",\n    \"route_id\": \"example-route\",\n    \"method\": \"GET\",\n    \"path\": \"/example\"\n  }\n]\n</code></pre> <p>This endpoint:</p> <ul> <li>is protected by admin auth and rate limiting, like the other <code>/admin/*</code> APIs,</li> <li>is consumed by the dashboard MCP view,</li> <li>should not expose secrets (it only reflects tool metadata).</li> </ul>"},{"location":"reference/mcp/#dashboard-integration","title":"Dashboard integration","text":"<p>The built-in dashboard includes:</p> <ul> <li>an MCP tools view listing tools from <code>/admin/mcp/tools</code> and showing:</li> <li><code>name</code> and <code>description</code>,</li> <li><code>route_id</code>,</li> <li><code>method</code> and <code>path</code>;</li> <li>an MCP config helper that generates a YAML fragment with <code>mcp.tools</code>   based on the current routes.</li> </ul> <p>The helper uses <code>/admin/routes</code> to list routes and produces a minimal config snippet such as:</p> <pre><code>mcp:\n  tools:\n    - name: \"route-one\"\n      description: \"\"\n      route_id: \"route-one\"\n      method: \"GET\"\n      path: \"/one\"\n</code></pre> <p>Operators can copy this fragment into the main Veilgate config or into a separate <code>mcp-tools.yaml</code> file and adjust names and descriptions as needed.</p> <p>The dashboard does not write or reload config files directly; it only assists with generating YAML, keeping the operational model simple and safe.</p>"},{"location":"reference/mcp/#mcp-scaffolding-via-cli","title":"MCP scaffolding via CLI","text":"<p>The <code>veilgate mcp init</code> command scaffolds a minimal MCP server project that can call APIs behind Veilgate:</p> <pre><code>veilgate mcp init -dir ./my-mcp-server -name my-mcp -desc \"My MCP server\" \\\n  -base-url http://localhost:8080 -route-id example-route\n</code></pre> <p>Scaffolding produces:</p> <ul> <li><code>main.go</code> \u2013 example MCP server using <code>internal/mcp</code>,</li> <li><code>README.md</code> \u2013 run instructions and an example MCP config snippet,</li> <li><code>mcp-tools.yaml</code> \u2013 a sample MCP configuration for Veilgate:</li> </ul> <pre><code>mcp:\n  tools:\n    - name: \"my-mcp_example\"\n      description: \"My MCP server\"\n      route_id: \"example-route\"\n      method: \"GET\"\n      path: \"/\"\n</code></pre> <p>You can merge <code>mcp-tools.yaml</code> into your main Veilgate config (or load it as an additional file, depending on your configuration tooling) and then adjust <code>route_id</code>, <code>method</code> and <code>path</code> to point at real routes.</p>"},{"location":"reference/mcp/#exporting-mcp-servers-from-the-dashboard","title":"Exporting MCP servers from the dashboard","text":"<p>In addition to manual scaffolding via CLI, you can design MCP tools in the dashboard and export a ready-to-run MCP server as a ZIP archive.</p>"},{"location":"reference/mcp/#workflow","title":"Workflow","text":"<ol> <li>Open the MCP Tools tab in the dashboard.</li> <li>Use Design tools to:</li> <li>create, edit and delete MCP tools,</li> <li>compose an \\\"API surface\\\" by selecting multiple routes and generating      tools for them.</li> <li>Switch to Export MCP server:</li> <li>choose which tools to include (by default all),</li> <li>provide MCP server name, directory inside the ZIP and base URL,</li> <li>click Download MCP server ZIP.</li> </ol> <p>The ZIP archive contains:</p> <ul> <li><code>main.go</code> \u2013 minimal MCP server using Veilgate's internal MCP library,</li> <li><code>README.md</code> \u2013 build and run instructions, plus wiring notes,</li> <li><code>mcp-tools.yaml</code> \u2013 a config snippet with the selected tools.</li> </ul> <p>You can:</p> <ul> <li>build and run the MCP server binary alongside Veilgate,</li> <li>merge <code>mcp-tools.yaml</code> into your gateway configuration,</li> <li>configure your MCP-compatible client to talk to the new MCP server.</li> </ul>"},{"location":"reference/mcp/#summary","title":"Summary","text":"<ul> <li><code>GatewayConfig.mcp.tools</code> defines a flat list of MCP tools,</li> <li><code>/admin/mcp/tools</code> exposes the effective tools to the dashboard and other   automation and supports CRUD,</li> <li><code>veilgate mcp init</code> and the dashboard's MCP server ZIP export make it easy to   bootstrap and maintain MCP integration without adding runtime complexity to   the gateway.</li> </ul>"},{"location":"reference/performance/","title":"Performance","text":"<p>Veilgate is designed to be a lightweight, high-performance API gateway with minimal overhead compared to direct backend access.</p>"},{"location":"reference/performance/#performance-goals","title":"Performance goals","text":"<p>Veilgate targets the following performance characteristics:</p> Metric Target Notes p95 latency overhead \u2264 1ms Pass-through proxy, small responses Throughput 10-20k RPS 2 vCPU, simple routes without TLS Memory footprint &lt; 50MB Base memory with typical configuration Startup time &lt; 1 second Cold start to ready <p>These targets assume: - Single gateway instance - No TLS termination at the gateway - Small response bodies (1-4 KB) - In-memory rate limiting and caching</p>"},{"location":"reference/performance/#running-benchmarks","title":"Running benchmarks","text":"<p>Veilgate includes a benchmark suite in <code>internal/perf/</code>. Run benchmarks with:</p> <pre><code># Quick benchmark run\ngo test -bench=. ./internal/perf/...\n\n# Extended run with more iterations\ngo test -bench=. -benchtime=5s ./internal/perf/...\n\n# With memory allocation stats\ngo test -bench=. -benchmem ./internal/perf/...\n</code></pre>"},{"location":"reference/performance/#available-benchmarks","title":"Available benchmarks","text":"Benchmark Description <code>BenchmarkGatewayRoundTrip</code> Basic proxy pass-through <code>BenchmarkGatewayWithCORS</code> CORS middleware overhead <code>BenchmarkGatewayWithRateLimit</code> Rate limiting middleware overhead <code>BenchmarkGatewayWithCache</code> Response caching (cache hit) <code>BenchmarkGatewayWithRewrite</code> Path rewriting overhead <code>BenchmarkGatewayWithResponseHeaders</code> Response header manipulation <code>BenchmarkGatewayAllFeatures</code> All middleware combined <code>BenchmarkGatewayLargeBody</code> Large request/response handling <code>BenchmarkGatewayManyRoutes</code> Routing with 100 routes"},{"location":"reference/performance/#interpreting-results","title":"Interpreting results","text":"<p>Example output:</p> <pre><code>BenchmarkGatewayRoundTrip-4      50000     28456 ns/op    1024 B/op    12 allocs/op\n</code></pre> <ul> <li><code>50000</code> \u2013 number of iterations</li> <li><code>28456 ns/op</code> \u2013 nanoseconds per operation (~28 \u03bcs)</li> <li><code>1024 B/op</code> \u2013 bytes allocated per operation</li> <li><code>12 allocs/op</code> \u2013 heap allocations per operation</li> </ul>"},{"location":"reference/performance/#performance-tuning","title":"Performance tuning","text":""},{"location":"reference/performance/#connection-pooling","title":"Connection pooling","text":"<p>Configure HTTP transport settings for your workload:</p> <pre><code>server:\n  http:\n    max_idle_conns: 512\n    max_idle_conns_per_host: 128\n    idle_conn_timeout_seconds: 90\n</code></pre> <p>More idle connections reduce connection establishment overhead but consume memory.</p>"},{"location":"reference/performance/#rate-limiting-scope","title":"Rate limiting scope","text":"<p>Rate limiting scope affects performance:</p> <ul> <li><code>route</code> \u2013 fastest, single limiter per route</li> <li><code>ip</code> \u2013 requires IP extraction, per-IP limiters</li> <li><code>api_key</code> \u2013 requires auth context, per-key limiters</li> </ul> <p>For high-throughput routes, consider <code>route</code> scope with appropriate limits.</p>"},{"location":"reference/performance/#caching","title":"Caching","text":"<p>Enable caching for idempotent endpoints:</p> <pre><code>routes:\n  - id: products-api\n    path: /api/products/*\n    method: GET\n    upstream_id: products\n    cache:\n      enable: true\n      ttl_seconds: 300\n</code></pre> <p>Cache hits bypass the upstream entirely, providing significant latency reduction.</p>"},{"location":"reference/performance/#response-headers","title":"Response headers","text":"<p>Minimize header manipulation for latency-sensitive routes:</p> <pre><code>routes:\n  - id: latency-critical\n    path: /api/realtime/*\n    method: GET\n    upstream_id: realtime\n    # No response_headers section = no processing overhead\n</code></pre>"},{"location":"reference/performance/#comparison-with-tyk","title":"Comparison with Tyk","text":"<p>Veilgate is designed to be simpler and faster than Tyk by:</p> <ul> <li>No embedded scripting \u2013 No JSVM or Go plugins in the hot path</li> <li>No external dependencies \u2013 No Redis/Mongo required for core functionality</li> <li>Minimal middleware \u2013 Only the middleware you configure is executed</li> <li>Efficient routing \u2013 chi router with zero-allocation path matching</li> <li>Shared transports \u2013 Connection pooling shared across routes</li> </ul> <p>Typical improvements over Tyk: - 30-50% lower latency for pass-through proxy - 60-80% lower memory footprint - Faster cold starts (&lt; 1s vs 5-10s)</p>"},{"location":"reference/performance/#load-testing","title":"Load testing","text":"<p>For production capacity planning, use external load testing tools:</p>"},{"location":"reference/performance/#using-hey","title":"Using hey","text":"<pre><code># Install hey\ngo install github.com/rakyll/hey@latest\n\n# Basic load test\nhey -n 10000 -c 100 http://localhost:8080/api/health\n\n# With authentication\nhey -n 10000 -c 100 -H \"X-API-Key: your-key\" http://localhost:8080/api/data\n</code></pre>"},{"location":"reference/performance/#using-wrk","title":"Using wrk","text":"<pre><code># Basic test\nwrk -t4 -c100 -d30s http://localhost:8080/api/health\n\n# With script for POST requests\nwrk -t4 -c100 -d30s -s post.lua http://localhost:8080/api/data\n</code></pre>"},{"location":"reference/performance/#using-vegeta","title":"Using vegeta","text":"<pre><code># Create target file\necho \"GET http://localhost:8080/api/health\" | vegeta attack -rate=1000 -duration=30s | vegeta report\n</code></pre>"},{"location":"reference/performance/#profiling","title":"Profiling","text":""},{"location":"reference/performance/#cpu-profiling","title":"CPU profiling","text":"<pre><code># Enable pprof in admin server (if configured)\ngo tool pprof http://localhost:9090/debug/pprof/profile?seconds=30\n\n# From benchmark\ngo test -bench=BenchmarkGatewayRoundTrip -cpuprofile=cpu.out ./internal/perf/...\ngo tool pprof cpu.out\n</code></pre>"},{"location":"reference/performance/#memory-profiling","title":"Memory profiling","text":"<pre><code>go test -bench=BenchmarkGatewayRoundTrip -memprofile=mem.out ./internal/perf/...\ngo tool pprof mem.out\n</code></pre>"},{"location":"reference/performance/#trace","title":"Trace","text":"<pre><code>go test -bench=BenchmarkGatewayRoundTrip -trace=trace.out ./internal/perf/...\ngo tool trace trace.out\n</code></pre>"},{"location":"reference/performance/#production-monitoring","title":"Production monitoring","text":"<p>Monitor these metrics in production:</p> <ul> <li><code>veilgate_http_request_duration_seconds</code> \u2013 Request latency histogram</li> <li><code>veilgate_http_requests_total</code> \u2013 Request count by route and status</li> <li><code>veilgate_upstream_health</code> \u2013 Backend health status</li> <li><code>veilgate_ratelimit_rejections_total</code> \u2013 Rate limit events</li> <li>Process metrics (CPU, memory, goroutines)</li> </ul> <p>Set alerts for: - p99 latency exceeding SLO - High rate limit rejection rate - Upstream health degradation - Memory growth (potential leak)</p>"}]}