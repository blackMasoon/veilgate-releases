{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"CONTRIBUTING-DOCS/","title":"Contributing to documentation","text":"<p>This project treats the Markdown files under <code>docs/</code> as the single source of truth for product and technical documentation.</p>"},{"location":"CONTRIBUTING-DOCS/#where-to-put-things","title":"Where to put things","text":"<ul> <li><code>docs/overview/</code> \u2013 high-level product overview and positioning.</li> <li><code>docs/concepts/</code> \u2013 core concepts such as routes, upstreams, policies, admin API, MCP.</li> <li><code>docs/how-to/</code> \u2013 task-oriented guides (quickstart, securing routes, MCP, etc.).</li> <li><code>docs/reference/</code> \u2013 detailed references (configuration, admin API, MCP config, CLI).</li> </ul> <p>When adding or changing features:</p> <ol> <li>Decide which section the change belongs to.</li> <li>Add or update the relevant Markdown file(s), including frontmatter:</li> </ol> <p>```yaml</p> <p>title: Title of the page    description: One-line summary used by the docs site.</p> <p>```</p>"},{"location":"CONTRIBUTING-DOCS/#admin-api-and-generated-specs","title":"Admin API and generated specs","text":"<p>The structured definition of the admin API is generated from code, not edited by hand.</p> <ul> <li>The generator lives in <code>internal/docsgen</code>.</li> <li>The CLI entrypoint is:</li> </ul> <p><code>bash   go run ./cmd/veilgate docs export-admin-openapi \\     -out dist/docs-src/reference/admin-api.yaml \\     -version-file VERSION</code></p> <p>When adding or changing admin endpoints:</p> <ol> <li>Update the HTTP handlers in <code>internal/admin/admin.go</code>.</li> <li>Update the endpoint list in <code>internal/docsgen</code> so OpenAPI stays in sync.</li> <li>Adjust <code>docs/reference/admin-api.md</code> text if needed.</li> </ol>"},{"location":"CONTRIBUTING-DOCS/#release-and-publishing-flow","title":"Release and publishing flow","text":"<p>On release (via <code>.github/workflows/release.yml</code> + <code>scripts/release.sh</code>):</p> <ol> <li><code>scripts/release.sh</code> copies <code>docs/</code> into <code>dist/docs-src/</code> and runs the docs generator.</li> <li>The release workflow syncs <code>dist/docs-src/</code> into the <code>blackMasoon/veilgate-releases</code> repo.</li> <li>If <code>mkdocs.yml</code> exists in <code>veilgate-releases</code>, the workflow runs <code>mkdocs build</code> there.</li> </ol> <p>The MkDocs configuration and navigation live in the <code>veilgate-releases</code> repository. If you add a new page under <code>docs/</code>, remember to update the <code>mkdocs.yml</code> nav in that repo so it appears in the public documentation site.</p>"},{"location":"CONTRIBUTING-DOCS/#local-validation-optional","title":"Local validation (optional)","text":"<p>For local work you can:</p> <ul> <li>run <code>go vet ./...</code> and <code>go test ./...</code> as usual,</li> <li>run the docs generator command above to ensure OpenAPI still generates,</li> <li>run <code>mkdocs build</code> in a checkout of <code>veilgate-releases</code> to validate the full site.</li> </ul>"},{"location":"QUICKSTART/","title":"QUICKSTART","text":""},{"location":"QUICKSTART/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"QUICKSTART/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"QUICKSTART/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart.</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"QUICKSTART/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"QUICKSTART/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul>"},{"location":"QUICKSTART/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"QUICKSTART/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"QUICKSTART/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</code></p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"QUICKSTART/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"QUICKSTART/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"concepts/","title":"Core concepts","text":"<p>This section explains the core building blocks of Veilgate and how they fit together.</p> <ul> <li>Routes</li> <li>Upstreams</li> <li>Policies: auth &amp; rate limiting</li> <li>Enterprise licensing</li> <li>Admin API &amp; dashboard</li> <li>MCP tools</li> </ul>"},{"location":"concepts/admin-api/","title":"Admin API &amp; dashboard","text":"<p>Veilgate exposes a separate admin server for operators. It typically listens on a different port than user traffic and exposes:</p> <ul> <li>health endpoints (<code>/healthz</code>, <code>/readyz</code>),</li> <li>Prometheus metrics (<code>/metrics</code>),</li> <li>JSON admin endpoints under <code>/admin/...</code>,</li> <li>built\u2011in dashboard under <code>/dashboard</code>.</li> </ul> <p>The dashboard is a React SPA that consumes the admin JSON API to:</p> <ul> <li>display routes and their policies,</li> <li>display upstream pools and health,</li> <li>display MCP tools and their mappings (once configured),</li> <li>display summary statistics,</li> <li>manage configuration in place (when admin write access is enabled).</li> </ul>"},{"location":"concepts/admin-api/#dashboard-management-capabilities-crud","title":"Dashboard management capabilities (CRUD)","text":"<p>When the admin API is exposed with write access, the dashboard can:</p> <ul> <li>Routes</li> <li>List all effective routes (as before).</li> <li>Create new routes (<code>POST /admin/routes</code>) by filling in ID, method, host, path and upstream.</li> <li>Edit existing routes (<code>PUT /admin/routes/{id}</code>) \u2013 core routing fields can be adjusted at runtime.</li> <li>Delete routes (<code>DELETE /admin/routes/{id}</code>) \u2013 removed routes stop matching immediately.</li> <li> <p>Advanced auth and rate\u2011limit options are still primarily configured via YAML, but are validated and enforced on the updated runtime after each change.</p> </li> <li> <p>Upstreams</p> </li> <li>List upstream pools and endpoints.</li> <li>Create new upstreams (<code>POST /admin/upstreams</code>) by specifying an ID and one or more endpoint URLs.</li> <li>Edit upstream endpoints (<code>PUT /admin/upstreams/{id}</code>) \u2013 change or add/remove backend URLs.</li> <li> <p>Delete upstreams (<code>DELETE /admin/upstreams/{id}</code>); validation prevents removing upstreams still referenced by routes.</p> </li> <li> <p>API keys</p> </li> <li>View API keys defined in configuration (<code>security.api_keys</code>) as part of the policies view.</li> <li>Generate new API keys via the admin API (<code>POST /admin/security/api-keys</code>); the dashboard:<ul> <li>shows the generated key only once so it can be copied,</li> <li>updates the running configuration and key store immediately.</li> </ul> </li> <li>Activate/deactivate keys (<code>PUT /admin/security/api-keys/{id}</code>) by toggling their <code>active</code> status without removing them from history.</li> <li>Delete keys (<code>DELETE /admin/security/api-keys/{id}</code>) so they can no longer be used.</li> </ul> <p>All write operations go through the same safe flow:</p> <ol> <li>The admin server applies the change to an in\u2011memory copy of the configuration.</li> <li>The new config is validated against the same rules as the file\u2011based config.</li> <li>Runtime components (upstream registry, auth, rate limiting, router) are rebuilt.</li> <li>If everything succeeds, the new runtime is atomically swapped in; otherwise the dashboard shows a validation error and the previous config stays active.</li> </ol> <p>See the Admin API reference for endpoint\u2011level details and the write operations exposed under <code>/admin/routes</code>, <code>/admin/upstreams</code> and <code>/admin/security/api-keys</code>.</p>"},{"location":"concepts/licensing/","title":"Enterprise licensing","text":"<p>Veilgate Enterprise uses Ed25519-signed tokens to convey entitlements and bind them to a deployment identity. The gateway verifies licenses offline using a built-in public key (overridable via <code>VEILGATE_LICENSE_PUBKEY_B64</code>) and enforces limits early during startup and on admin-driven config mutations.</p> <ul> <li>Without a valid license: max 1 upstream, max 3 routes (demo mode).</li> <li>With a valid license: the license payload specifies <code>max_upstreams</code> and <code>max_routes</code>.</li> <li>Optional bindings: <code>instance_id</code> and <code>domains[]</code> allow scoping a license to a   specific gateway instance or hostnames.</li> <li>Optional expiry: <code>exp</code> enforced strictly; there is no silent grace period.</li> </ul> <p>Token format: <code>VEIL-1.&lt;base64url(payload JSON)&gt;.&lt;base64url(signature)&gt;</code></p> <ul> <li>signature = Ed25519(private_key, base64url(payload))</li> <li>verification = Ed25519(public_key, base64url(payload))</li> </ul> <p>The repository includes a minimal license server (<code>license-server/</code>) to generate and manage licenses. In production, the public key must be provisioned into the Veilgate runtime via <code>VEILGATE_LICENSE_PUBKEY_B64</code>, and the private key must be protected by your issuance infrastructure.</p> <p>Security hardening notes:</p> <ul> <li>Verification happens before router/materialization; invalid or insufficient   licenses fail the process fast. The same checks apply on admin config mutate.</li> <li>Tokens are small, offline-verifiable, and auditable (JSON payload).</li> <li>A CRL endpoint (<code>/crl</code>) is provided by the sample server; integrating periodic   revocation checks is possible without blocking startup.</li> <li>No secrets ship in the gateway binary; only a public key is needed.</li> </ul>"},{"location":"concepts/mcp/","title":"MCP tools","text":"<p>Veilgate provides first\u2011class integration with the Model Context Protocol (MCP).</p> <p>Key ideas:</p> <ul> <li>MCP tools wrap HTTP APIs behind Veilgate and expose them to LLM agents.</li> <li>Tools have descriptors (name, description, input/output schemas).</li> <li>A tool typically maps to one or more gateway routes by ID.</li> </ul> <p>The Veilgate CLI includes scaffolding to generate an MCP server that:</p> <ul> <li>calls Veilgate via HTTP,</li> <li>uses the same auth, rate limit and observability stack as regular clients.</li> </ul> <p>See the MCP how\u2011to guides and reference for details on configuring MCP tools.</p>"},{"location":"concepts/policies/","title":"Policies: auth & rate limiting","text":"<p>title: Policies: auth &amp; rate limiting description: Built-in security and rate limiting policies and how they attach to routes.</p>"},{"location":"concepts/policies/#policies-auth-rate-limiting","title":"Policies: auth &amp; rate limiting","text":"<p>Veilgate ships with built\u2011in policies for authentication and rate limiting.</p>"},{"location":"concepts/policies/#authentication","title":"Authentication","text":"<p>Veilgate ships with two first-class authentication mechanisms that mirror the Tyk setups we are replacing:</p> <ul> <li>API keys \u2013 static keys configured in <code>security.api_keys</code>. A single,   configurable header carries keys across all routes   (<code>security.api_keys_header_name</code>, default <code>X-API-Key</code>). When a particular API   needs to honor a legacy header (<code>Api-key</code>, <code>X-Customer-Key</code>, etc.), override   it per route via <code>routes[].auth.api_key_header_name</code>. The dashboard now   surfaces both the global default and per-route overrides so operators can   confirm exactly what the gateway expects.</li> <li>JWT \u2013 tokens issued by configurable providers. Veilgate supports HS256,   RS256 with a local PEM, and RS256 via JWKS discovery. JWKS issuers declare a   <code>jwks_url</code> and a positive <code>jwks_cache_ttl_seconds</code>; the gateway fetches and   caches keys, selecting the right one via the token's <code>kid</code>. Optional <code>issuer</code>   and <code>audience[]</code> claims are validated for every token.</li> </ul> <p>Policies can be attached to routes to enforce:</p> <ul> <li>specific key sets or header names,</li> <li>specific JWT issuers/audiences or downstream claim constraints.</li> </ul>"},{"location":"concepts/policies/#rate-limiting","title":"Rate limiting","text":"<p>Rate limiting is implemented as an efficient in\u2011memory token bucket.</p> <p>Limits can be configured per:</p> <ul> <li>API key (consumer),</li> <li>client IP,</li> <li>route.</li> </ul> <p>Policy configuration lives in the <code>rate_limit</code> section and is attached to routes via references.</p>"},{"location":"concepts/routes/","title":"Routes","text":"<p>Routes describe how Veilgate matches incoming HTTP requests and where they should be forwarded.</p> <p>Each route can match on:</p> <ul> <li>Host \u2013 HTTP <code>Host</code> header.</li> <li>Path \u2013 path prefix or pattern.</li> <li>Method \u2013 HTTP method such as <code>GET</code>, <code>POST</code>.</li> <li>Optional predicates \u2013 headers or query parameters.</li> </ul> <p>Matched routes are compiled into a Route Runtime which holds:</p> <ul> <li>upstream pool reference,</li> <li>middleware pipeline (auth, rate limiting, transforms),</li> <li>metadata (route ID, name, tags) used for metrics and observability.</li> </ul> <p>See the configuration reference for the exact YAML structure of routes.</p>"},{"location":"concepts/upstreams/","title":"Upstreams","text":"<p>Upstreams represent backend services that Veilgate proxies traffic to.</p> <p>Key ideas:</p> <ul> <li>Upstream pools \u2013 named sets of endpoints (hosts) with load\u2011balancing strategy.</li> <li>Health \u2013 each endpoint can be marked as up, degraded or down based on active/passive checks.</li> <li>Connection management \u2013 Veilgate uses tuned HTTP transports for connection pooling and timeouts.</li> </ul> <p>Routes reference upstream pools by ID, so you can:</p> <ul> <li>reuse upstreams across many routes,</li> <li>change upstream details without touching route definitions.</li> </ul>"},{"location":"deploy/fly/","title":"Fly","text":""},{"location":"deploy/fly/#flyio-test-deploy-gateway-portal-license-admin","title":"Fly.io test deploy (gateway + portal + license admin)","text":"<p>This repository includes a CI workflow that deploys test instances to Fly.io on every merge to the default branch.</p> <p>Components: - <code>veilgate-test-gw</code> \u2014 gateway (ports 80/443) and admin/dashboard (port 9090) - <code>veilgate-test-license</code> \u2014 license admin/portal (port 9400)</p> <p>Both apps are configured as single-machine, scale-to-zero (auto-stop/auto-start) instances.</p>"},{"location":"deploy/fly/#files","title":"Files","text":"<ul> <li><code>fly.gw.toml</code> \u2014 Fly app config for gateway+portal (root-level, poprawny kontekst builda)</li> <li><code>fly.license.toml</code> \u2014 Fly app config for license admin (root-level)</li> <li><code>examples/fly/veilgate.yaml</code> \u2014 Minimal test config (&lt;= 3 routes, 1 upstream)</li> <li><code>.github/workflows/fly-deploy.yml</code> \u2014 GitHub Actions workflow</li> </ul>"},{"location":"deploy/fly/#required-repository-secrets","title":"Required repository secrets","text":"<p>Set these in your GitHub repository settings \u2192 Secrets and variables \u2192 Actions:</p> <ul> <li><code>FLY_API_TOKEN</code> \u2014 Fly.io access token</li> <li><code>FLY_ORG</code> \u2014 (opcjonalny) slug organizacji Fly; wymagany tylko, je\u015bli masz wiele org\u00f3w i chcesz wymusi\u0107 konkretn\u0105</li> </ul> <p>License server (admin + portal seed on first deploy): - <code>LICENSE_ADMIN_TOKEN</code> \u2014 bearer token for JSON admin API - <code>LICENSE_PORTAL_ADMIN_USER</code> \u2014 initial portal admin username - <code>LICENSE_PORTAL_ADMIN_PASSWORD</code> \u2014 initial portal admin password - <code>LICENSE_SESSION_SECRET</code> \u2014 HMAC secret for portal sessions</p> <p>Veilgate admin (dashboard login seed on first deploy): - <code>VEILGATE_DEV_ADMIN_USER</code> \u2014 initial admin username - <code>VEILGATE_DEV_ADMIN_PASSWORD</code> \u2014 initial admin password - <code>VEILGATE_ADMIN_SESSION_SECRET</code> \u2014 session secret for admin auth</p> <p>The deployment workflow automatically issues a test license for the Veilgate instance after deploying the license server: 1. Waits for the license server to become ready 2. Fetches the public key from the license server 3. Issues a license with enterprise limits (100 upstreams, 1000 routes, 365 days validity) 4. Configures the Veilgate instance with the license via secrets</p> <p>The license is bound to the instance ID matching the app name (default: <code>veilgate-test-gw</code>) and includes all enterprise features (jwt, ratelimit, oauth2, mtls).</p>"},{"location":"deploy/fly/#access","title":"Access","text":"<ul> <li>Domy\u015blne nazwy aplikacji to <code>veilgate-test-gw</code> i <code>veilgate-test-license</code>. Mo\u017cesz je nadpisa\u0107 repozytoryjnymi Variables <code>FLY_GW_APP</code> i <code>FLY_LICENSE_APP</code>.</li> <li>Gateway: <code>https://&lt;GW_APP&gt;.fly.dev/</code></li> <li>Admin/dashboard: <code>https://&lt;GW_APP&gt;.fly.dev:9090/dashboard</code> (login z VEILGATE_DEV_*)</li> <li>License portal: <code>https://&lt;LICENSE_APP&gt;.fly.dev:9400/portal</code></li> </ul>"},{"location":"deploy/fly/#persistence","title":"Persistence","text":"<ul> <li>Both apps mount Fly volumes under <code>/data</code>:</li> <li><code>veilgate_data</code> for the gateway (persists the admin store and runtime config).</li> <li><code>veilgate_license_data</code> for the license-server (persists the BoltDB file).</li> <li>The gateway saves mutations to <code>VEILGATE_CONFIG_PERSIST_PATH</code> (default <code>/data/veilgate.runtime.yaml</code>) and keeps admin users in <code>VEILGATE_ADMIN_STORE_PATH</code> (default <code>/data/admin-users.db</code>).</li> <li>The <code>fly-deploy.yml</code> workflow automatically creates required volumes before deploy so changes made via the Admin API or license portal survive restarts/redeployments.</li> </ul>"},{"location":"deploy/fly/#scale-to-zero","title":"Scale-to-zero","text":"<p>Both apps in <code>fly.toml</code> have: - <code>auto_stop_machines = \"stop\"</code> - <code>auto_start_machines = true</code> - <code>min_machines_running = 0</code></p> <p>This keeps costs minimal and wakes machines on incoming requests.</p>"},{"location":"how-to/","title":"How\u2011to guides","text":"<p>Start here for practical, task\u2011oriented guides:</p> <ul> <li>Quickstart: Docker + docker-compose</li> <li>Pe\u0142ny setup: od ZIP do Docker w chmurze</li> <li>Dashboard guide</li> <li>Migrating from Tyk</li> <li>(Planned) Securing routes with API keys and JWT</li> <li>(Planned) Rate limiting common scenarios</li> <li>(Planned) Exposing an API as an MCP tool</li> </ul>"},{"location":"how-to/dashboard-guide/","title":"Dashboard guide","text":"<p>The Veilgate dashboard provides a web-based interface for monitoring gateway health, managing routes, and configuring security policies.</p>"},{"location":"how-to/dashboard-guide/#accessing-the-dashboard","title":"Accessing the dashboard","text":"<p>The dashboard is served by the admin server (default port 9090):</p> <pre><code>http://localhost:9090/dashboard\n</code></pre> <p>If admin authentication is configured, you'll be prompted to log in first.</p>"},{"location":"how-to/dashboard-guide/#overview-page","title":"Overview page","text":"<p>The Overview page displays:</p> <ul> <li>Gateway status: Health and readiness indicators</li> <li>Quick stats: Total routes, APIs, and active API keys</li> <li>Top routes: Routes with the most traffic</li> <li>Top API keys: Most active API keys by request count</li> </ul> <p>This page auto-refreshes to show current statistics.</p>"},{"location":"how-to/dashboard-guide/#routes-view","title":"Routes view","text":"<p>The Routes view allows you to manage all gateway routes.</p>"},{"location":"how-to/dashboard-guide/#viewing-routes","title":"Viewing routes","text":"<p>The routes table displays:</p> Column Description ID Unique route identifier Method HTTP method(s) matched Host Optional host matcher Path URL path pattern API Target backend API Auth Authentication requirements Rate Limit Rate limiting configuration Features Active features (CORS, cache, rewrite, etc.)"},{"location":"how-to/dashboard-guide/#creating-a-route","title":"Creating a route","text":"<ol> <li>Click Add route</li> <li>Fill in the required fields:</li> <li>ID: Unique identifier (e.g., <code>orders-api-v2</code>)</li> <li>Method: HTTP method or <code>*</code> for all</li> <li>Path: URL pattern (e.g., <code>/api/v1/*</code>)</li> <li>API ID: Target backend API</li> <li>Configure optional features:</li> <li>Rewrite: Path prefix stripping/adding</li> <li>CORS: Cross-origin settings</li> <li>Response Headers: Add/remove headers</li> <li>Cache: Response caching</li> <li>Proxy: Host and TLS options</li> <li>IP Filter: CIDR-based access control</li> <li>Click Create route</li> </ol>"},{"location":"how-to/dashboard-guide/#editing-a-route","title":"Editing a route","text":"<ol> <li>Click Edit next to the route</li> <li>Modify the desired fields</li> <li>Click Save changes</li> </ol> <p>Note: Route ID cannot be changed after creation.</p>"},{"location":"how-to/dashboard-guide/#deleting-a-route","title":"Deleting a route","text":"<ol> <li>Click Delete next to the route</li> <li>Confirm the deletion</li> </ol> <p>Warning: Deletion is immediate and cannot be undone.</p>"},{"location":"how-to/dashboard-guide/#route-features","title":"Route features","text":"<p>The Features column shows pills for active features:</p> <ul> <li>rewrite: Path rewriting is configured</li> <li>CORS: Cross-origin requests enabled</li> <li>headers: Response header manipulation</li> <li>cache: Response caching enabled</li> <li>proxy: Custom proxy settings</li> <li>IP filter: IP-based access control</li> </ul>"},{"location":"how-to/dashboard-guide/#apis-view","title":"APIs view","text":"<p>Manage backend API services in the APIs view.</p>"},{"location":"how-to/dashboard-guide/#viewing-apis","title":"Viewing APIs","text":"<p>The table shows:</p> Column Description API ID Unique API identifier Target URLs Backend server URLs"},{"location":"how-to/dashboard-guide/#creating-an-api","title":"Creating an API","text":"<ol> <li>Click Add API</li> <li>Enter the API ID</li> <li>Add target URLs (one per line)</li> <li>Click Create API</li> </ol>"},{"location":"how-to/dashboard-guide/#editing-an-api","title":"Editing an API","text":"<ol> <li>Click Edit next to the API</li> <li>Modify target URLs</li> <li>Click Save changes</li> </ol>"},{"location":"how-to/dashboard-guide/#deleting-an-api","title":"Deleting an API","text":"<ol> <li>Click Delete next to the API</li> <li>Confirm the deletion</li> </ol> <p>Note: You cannot delete an API that is referenced by routes.</p>"},{"location":"how-to/dashboard-guide/#policies-view","title":"Policies view","text":"<p>The Policies view manages gateway-wide authentication defaults, the fallback rate limit, and the credentials/routes can reference (API keys and JWT issuers). Routes can override these defaults per route, but they inherit them when nothing is set locally.</p>"},{"location":"how-to/dashboard-guide/#api-keys-section","title":"API Keys section","text":"<p>Displays configured API keys (both config-defined and generated in the UI) with:</p> <ul> <li>ID and label</li> <li>Active/inactive status</li> <li>Default header name (global setting used by API key auth)</li> </ul>"},{"location":"how-to/dashboard-guide/#defaults-section","title":"Defaults section","text":"<ul> <li>Global API key header used when routes enable API-key auth</li> <li>Default rate limit applied when a route has no per-route limit configured</li> </ul>"},{"location":"how-to/dashboard-guide/#jwt-issuers-section","title":"JWT Issuers section","text":"<p>Shows configured JWT providers:</p> <ul> <li>Issuer ID and URL</li> <li>Algorithm (HS256, RS256, JWKS)</li> <li>Audience constraints</li> <li>JWKS URL and cache TTL (for JWKS)</li> </ul>"},{"location":"how-to/dashboard-guide/#managing-api-keys","title":"Managing API keys","text":"<p>API keys are credentials, not policies. Use them when a route requires API key auth; clients must send the key in the configured header.</p>"},{"location":"how-to/dashboard-guide/#generating-a-new-key","title":"Generating a new key","text":"<ol> <li>Optionally enter a Label</li> <li>Click Generate API key</li> <li>Copy the key immediately \u2013 it won't be shown again</li> </ol>"},{"location":"how-to/dashboard-guide/#activatingdeactivating-keys","title":"Activating/Deactivating keys","text":"<ol> <li>Find the key in the table</li> <li>Click Activate or Deactivate</li> </ol>"},{"location":"how-to/dashboard-guide/#deleting-keys","title":"Deleting keys","text":"<ol> <li>Click Delete next to the key</li> <li>Confirm the deletion</li> </ol>"},{"location":"how-to/dashboard-guide/#mcp-tools-view","title":"MCP Tools view","text":"<p>Manage Model Context Protocol (MCP) tool definitions.</p>"},{"location":"how-to/dashboard-guide/#current-tools","title":"Current tools","text":"<p>Lists configured MCP tools with:</p> <ul> <li>Name and description</li> <li>Linked route ID</li> <li>HTTP method and path</li> </ul>"},{"location":"how-to/dashboard-guide/#design-tools","title":"Design tools","text":"<p>Generate MCP tool configurations:</p> <ol> <li>Select routes to expose as tools</li> <li>Add descriptions</li> <li>Export configuration snippet</li> </ol>"},{"location":"how-to/dashboard-guide/#export-mcp-server","title":"Export MCP server","text":"<p>Generate a complete MCP server project:</p> <ol> <li>Select tools to include</li> <li>Configure server metadata</li> <li>Download as ZIP</li> </ol>"},{"location":"how-to/dashboard-guide/#security-metrics-view","title":"Security Metrics view","text":"<p>Monitor authentication and rate limiting events.</p>"},{"location":"how-to/dashboard-guide/#auth-failures","title":"Auth failures","text":"<p>Shows authentication failure counts by:</p> <ul> <li>Route ID</li> <li>Failure reason (API key, JWT, etc.)</li> </ul>"},{"location":"how-to/dashboard-guide/#rate-limit-rejections","title":"Rate limit rejections","text":"<p>Displays rate limiting events by:</p> <ul> <li>Route ID</li> <li>Scope (IP, API key, route)</li> </ul>"},{"location":"how-to/dashboard-guide/#dashboard-authentication","title":"Dashboard authentication","text":"<p>When <code>admin_auth</code> is configured, the dashboard requires login.</p>"},{"location":"how-to/dashboard-guide/#logging-in","title":"Logging in","text":"<ol> <li>Navigate to <code>/dashboard</code></li> <li>Enter username and password</li> <li>Click Login</li> </ol> <p>The session is stored in an HTTP-only cookie.</p>"},{"location":"how-to/dashboard-guide/#logging-out","title":"Logging out","text":"<ol> <li>Click Logout in the navigation</li> <li>Confirm logout</li> </ol>"},{"location":"how-to/dashboard-guide/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"Key Action <code>r</code> Refresh current view <code>h</code> Go to Overview <code>?</code> Show help"},{"location":"how-to/dashboard-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/dashboard-guide/#dashboard-not-loading","title":"Dashboard not loading","text":"<ol> <li>Check that the admin server is running on the correct port</li> <li>Verify no firewall rules blocking access</li> <li>Check browser console for errors</li> </ol>"},{"location":"how-to/dashboard-guide/#login-issues","title":"Login issues","text":"<ol> <li>Verify admin credentials are configured</li> <li>Check that cookies are enabled</li> <li>Try clearing browser cookies</li> </ol>"},{"location":"how-to/dashboard-guide/#data-not-updating","title":"Data not updating","text":"<ol> <li>Click refresh or press <code>r</code></li> <li>Check gateway health status</li> <li>Verify admin API is responding</li> </ol>"},{"location":"how-to/dashboard-guide/#cors-errors-in-browser","title":"CORS errors in browser","text":"<p>The dashboard makes requests to the admin API on the same origin. If you're running the dashboard from a different origin:</p> <ol> <li>Configure CORS on the admin server</li> <li>Or access via the same origin</li> </ol>"},{"location":"how-to/dashboard-guide/#api-access","title":"API access","text":"<p>All dashboard functionality is backed by the admin JSON API. You can use these endpoints directly for automation:</p> <pre><code># List routes\ncurl http://localhost:9090/admin/routes\n\n# Create route\ncurl -X POST http://localhost:9090/admin/routes \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\":\"new-route\",\"path\":\"/new/*\",\"method\":\"*\",\"upstream_id\":\"backend\"}'\n\n# Get statistics\ncurl http://localhost:9090/admin/stats/routes\n</code></pre> <p>See the Admin API reference for complete documentation.</p>"},{"location":"how-to/end-user-setup/","title":"Pe\u0142ny setup Veilgate \u2013 krok po kroku","text":"<p>Ten przewodnik przeprowadzi Ci\u0119 przez ca\u0142y proces uruchomienia Veilgate: - pobranie binari\u00f3w (ZIP) z wyda\u0144, - przygotowanie i weryfikacj\u0119 licencji, - wst\u0119pn\u0105 konfiguracj\u0119 YAML, - uruchomienie w Dockerze (lokalnie lub w dowolnej chmurze), - podstawow\u0105 diagnostyk\u0119 i dobre praktyki bezpiecze\u0144stwa.</p> <p>Uwaga o licencjach: Veilgate wymaga wa\u017cnej licencji dla konfiguracji wykraczaj\u0105cych poza tryb demo. W sprawie licencji (indywidualne warunki) skontaktuj si\u0119: adam@veilgate.tech</p>"},{"location":"how-to/end-user-setup/#1-wymagania-wstepne","title":"1) Wymagania wst\u0119pne","text":"<ul> <li>System z Docker / Docker Desktop lub \u015brodowiskiem uruchomieniowym kontener\u00f3w (ECS/Fargate, GKE, AKS, K8s, Nomad, itp.).</li> <li><code>curl</code> i <code>jq</code> (do szybkich test\u00f3w i inspekcji JSON).</li> <li>Otwarty ruch do port\u00f3w publicznych (domy\u015blnie 80/443 dla gateway, 9090 dla panelu admin) \u2013 w chmurze zwykle za load balancerem z TLS.</li> </ul>"},{"location":"how-to/end-user-setup/#2-pobranie-paczki-zip","title":"2) Pobranie paczki (ZIP)","text":"<ol> <li>Przejd\u017a do strony wyda\u0144 Veilgate i pobierz najnowsz\u0105 paczk\u0119 ZIP dla swojej platformy.</li> <li>Rozpakuj ZIP \u2013 w katalogu znajdziesz binarium <code>veilgate</code> i przyk\u0142adowe konfiguracje w <code>config/</code>.</li> </ol> <p>Alternatywa: mo\u017cesz u\u017cy\u0107 gotowego obrazu Docker dostarczanego wraz z wydaniem.</p>"},{"location":"how-to/end-user-setup/#3-pozyskanie-i-ustawienie-licencji","title":"3) Pozyskanie i ustawienie licencji","text":"<p>Veilgate egzekwuje limity w trybie demo (np. max 1 upstream i 3 trasy). Aby odblokowa\u0107 pe\u0142n\u0105 funkcjonalno\u015b\u0107:</p> <ul> <li>Skontaktuj si\u0119 w sprawie licencji: adam@veilgate.tech (zalecane, warunki s\u0105 indywidualne).</li> <li>Po otrzymaniu tokenu licencyjnego (zaczyna si\u0119 od <code>VEIL-1.</code>) masz dwie opcje konfiguracji:</li> <li> <p>W pliku YAML (sekcja <code>license:</code>):</p> <p><code>yaml license:   key: \"VEIL-1.&lt;tw\u00f3j-token&gt;\"   instance_id: \"moja-instancja-gateway\"   # server_url: \"https://licenses.twojadomena\"  # opcjonalnie, je\u015bli korzystasz z walidacji online</code></p> </li> <li> <p>Jako zmienne \u015brodowiskowe (wygodne w chmurze):</p> <p>```bash export VEILGATE_LICENSE_KEY=\"VEIL-1.\" export VEILGATE_LICENSE_INSTANCE_ID=\"moja-instancja-gateway\""},{"location":"how-to/end-user-setup/#export-veilgate_license_server_urlhttpslicensestwojadomena","title":"export VEILGATE_LICENSE_SERVER_URL=\"https://licenses.twojadomena\"","text":"<p>```</p> <p>Veilgate automatycznie odczyta powy\u017csze zmienne w czasie startu.</p>"},{"location":"how-to/end-user-setup/#4-minimalna-konfiguracja-yaml","title":"4) Minimalna konfiguracja YAML","text":"<p>Plik <code>veilgate.yaml</code> (mo\u017cesz go nazwa\u0107 inaczej i wskaza\u0107 przez <code>-config ...</code>).</p> <pre><code>server:\n  listen_address: \":8080\"\n\nadmin:\n  listen_address: \":9090\"\n\nlogging:\n  level: \"info\"\n\nmetrics:\n  enabled: true\n\n# Przyk\u0142adowe zabezpieczenie kluczem API na trasie\nsecurity:\n  api_keys:\n    - id: \"client-1\"\n      key: \"super-tajny-klucz\"\n\nupstreams:\n  - id: \"backend-api\"\n    endpoints:\n      - url: \"https://api.twojadomena\"\n\nroutes:\n  - id: \"root\"\n    path: \"/\"\n    method: \"GET\"\n    upstream_id: \"backend-api\"\n    auth:\n      api_key: true\n</code></pre> <p>W produkcji trasy zwykle rozszerzysz o CORS, limity, przepisywanie \u015bcie\u017cek, itp. \u2013 patrz \u201eReference: configuration\u201d.</p>"},{"location":"how-to/end-user-setup/#5-uruchomienie-w-dockerze-lokalnie-i-w-chmurze","title":"5) Uruchomienie w Dockerze (lokalnie i w chmurze)","text":""},{"location":"how-to/end-user-setup/#opcja-a-docker-run","title":"Opcja A \u2013 docker run","text":"<pre><code>docker run --rm -p 8080:8080 -p 9090:9090 \\\n  -e VEILGATE_LICENSE_KEY=\"$VEILGATE_LICENSE_KEY\" \\\n  -e VEILGATE_LICENSE_INSTANCE_ID=\"$VEILGATE_LICENSE_INSTANCE_ID\" \\\n  -v $(pwd)/veilgate.yaml:/etc/veilgate/config.yaml:ro \\\n  ghcr.io/your-org/veilgate:&lt;wersja&gt; \\\n  /app/veilgate serve -config /etc/veilgate/config.yaml\n</code></pre> <p>W chmurze zamie\u0144 mapowanie port\u00f3w na odpowiedni\u0105 definicj\u0119 us\u0142ugi / LB. Zalecamy TLS na warstwie LB (443) i HTTP mi\u0119dzy LB a kontenerem.</p>"},{"location":"how-to/end-user-setup/#opcja-b-docker-compose","title":"Opcja B \u2013 docker-compose","text":"<p><code>docker-compose.yml</code> (fragment):</p> <pre><code>version: \"3.9\"\nservices:\n  veilgate:\n    image: ghcr.io/your-org/veilgate:&lt;wersja&gt;\n    ports: [\"8080:8080\", \"9090:9090\"]\n    environment:\n      VEILGATE_LICENSE_KEY: ${VEILGATE_LICENSE_KEY}\n      VEILGATE_LICENSE_INSTANCE_ID: ${VEILGATE_LICENSE_INSTANCE_ID}\n    volumes:\n      - ./veilgate.yaml:/etc/veilgate/config.yaml:ro\n    command: [\"/app/veilgate\", \"serve\", \"-config\", \"/etc/veilgate/config.yaml\"]\n</code></pre> <p>Uruchom:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"how-to/end-user-setup/#opcja-c-dowolna-chmura-orkiestrator","title":"Opcja C \u2013 dowolna chmura / orkiestrator","text":"<ul> <li>Zbuduj/pushnij obraz do rejestru (ECR/GCR/ACR/ghcr.io).</li> <li>Zadeklaruj zmienne \u015brodowiskowe licencji i mount z konfiguracj\u0105 YAML.</li> <li>Wystaw gateway za pomoc\u0105 LB (HTTPS 443) \u2013 admin najlepiej za prywatnym LB/VPN lub zabezpieczony (w Veilgate: sesje admin i rate limit na /admin/*).</li> </ul>"},{"location":"how-to/end-user-setup/#6-weryfikacja-dziaania","title":"6) Weryfikacja dzia\u0142ania","text":"<pre><code># Readiness admin (zalecane HTTPS przez LB)\ncurl -i http://&lt;host&gt;:9090/readyz\n\n# Trasa chroniona API key (przyk\u0142ad)\ncurl -i -H \"X-API-Key: super-tajny-klucz\" https://&lt;host&gt;/\n</code></pre> <p>Je\u015bli u\u017cywasz TLS na LB, pami\u0119taj o w\u0142a\u015bciwych hostach/SNI przy rozmowie z backendami (opcja <code>proxy.tls</code> lub <code>preserve_host_header</code>).</p>"},{"location":"how-to/end-user-setup/#7-najczestsze-problemy-i-rozwiazania","title":"7) Najcz\u0119stsze problemy i rozwi\u0105zania","text":"<ul> <li>502/504: <code>timeout awaiting response headers</code> \u2013 sprawd\u017a dost\u0119pno\u015b\u0107 i op\u00f3\u017anienia upstream, ewentualnie zwi\u0119ksz <code>server.http.response_header_timeout_seconds</code> lub per-route <code>proxy.timeouts</code>.</li> <li>B\u0142\u0119dy TLS do upstream: skonfiguruj <code>proxy.tls.insecure_skip_verify: false</code> (domy\u015blnie) i/lub SNI (<code>preserve_host_header: true</code>), w razie prywatnego CA dostarcz trust store w obrazie.</li> <li>Komunikat o licencji: upewnij si\u0119, \u017ce <code>license.key</code> (lub <code>VEILGATE_LICENSE_KEY</code>) i <code>instance_id</code> s\u0105 ustawione; rozmiar <code>routes</code>/<code>upstreams</code> musi mie\u015bci\u0107 si\u0119 w limitach licencji.</li> </ul>"},{"location":"how-to/end-user-setup/#8-bezpieczenstwo-i-dobre-praktyki","title":"8) Bezpiecze\u0144stwo i dobre praktyki","text":"<ul> <li>Nie wystawiaj publicznie admina na 9090 bez ochrony \u2013 u\u017cyj prywatnego LB/VPN lub kontrolowanego dost\u0119pu.</li> <li>Konfiguracje wra\u017cliwe trzymaj w zmiennych \u015brodowiskowych / managerze sekret\u00f3w, nie w repo.</li> <li>Stosuj <code>min_machines_running</code> i autoscaling wg potrzeb (dla platform typu Fly/K8s), ale pami\u0119taj o cold\u2011startach.</li> </ul>"},{"location":"how-to/end-user-setup/#9-gdzie-po-pomoc-i-licencje","title":"9) Gdzie po pomoc i licencj\u0119","text":"<ul> <li>Kontakt w sprawie licencji (zalecane, indywidualne ustalenia):</li> <li>adam@veilgate.tech</li> <li>Zg\u0142oszenia techniczne / wsparcie wdro\u017ceniowe: ten sam adres lub kana\u0142 projektu.</li> </ul>"},{"location":"how-to/functional-tests/","title":"Functional tests","text":"<p>Two end-to-end flows are available to validate the full stack, including issuing a license and running smoke tests.</p>"},{"location":"how-to/functional-tests/#1-local-functional-test-images-from-repo","title":"1) Local functional test (images from repo)","text":"<p>Script: <code>scripts/func-test.sh</code></p> <ul> <li>Builds Docker images for <code>veilgate</code>, <code>demo-upstream</code>, and <code>license-server</code> from the repo.</li> <li>Starts <code>license-server</code>, issues a development license, injects it into a config.</li> <li>Starts <code>demo-upstream</code> and <code>veilgate</code> and runs smoke tests:</li> <li>GET <code>/</code> (JSON response)</li> <li>CRUD on <code>/items</code></li> <li>Tears down and cleans temporary artifacts.</li> </ul> <p>Requirements: Docker, docker compose, <code>jq</code>, <code>curl</code>.</p> <p>Run:</p> <pre><code>scripts/func-test.sh\n</code></pre>"},{"location":"how-to/functional-tests/#2-release-zip-functional-test","title":"2) Release ZIP functional test","text":"<p>Script: <code>scripts/func-test-zip.sh</code></p> <ul> <li>Invokes <code>scripts/release.sh --bump none --no-push --compose-local</code> to create a release ZIP that references locally tagged images.</li> <li>Unzips the release, starts <code>license-server</code> separately, issues a license and injects it into the unzipped <code>config/veilgate.yaml</code>.</li> <li>Adds <code>VEILGATE_LICENSE_PUBKEY_B64</code> environment into the composed <code>veilgate</code> service and starts the stack from the ZIP.</li> <li>Runs the same smoke tests as the local functional test and tears down the stack.</li> </ul> <p>Requirements: Docker, docker compose, <code>jq</code>, <code>curl</code>, <code>unzip</code>.</p> <p>Run:</p> <pre><code>scripts/func-test-zip.sh\n</code></pre>"},{"location":"how-to/functional-tests/#ci-integration","title":"CI integration","text":"<p>The GitHub Actions workflow (<code>.github/workflows/ci.yml</code>) runs both functional tests on pushes and PRs:</p> <ul> <li><code>functional-test</code> \u2013 local images flow</li> <li><code>functional-test-zip</code> \u2013 release ZIP flow (using <code>--no-push</code> and <code>--compose-local</code>)</li> </ul> <p>These jobs depend on the <code>build-and-test</code> job to ensure unit tests pass before running end-to-end checks.</p>"},{"location":"how-to/local-ci/","title":"Local CI","text":"<p>This repo provides scripts and Make targets to run the same checks locally that CI runs.</p>"},{"location":"how-to/local-ci/#quick-start","title":"Quick start","text":"<p>Requirements:</p> <ul> <li>Go (&gt;= 1.23)</li> <li>Docker + docker compose</li> <li><code>curl</code>, <code>jq</code>, <code>unzip</code> (for functional tests)</li> </ul> <p>Run everything:</p> <pre><code>make local-ci\n</code></pre> <p>This runs:</p> <ul> <li><code>go mod tidy</code></li> <li><code>go test ./...</code></li> <li>Build Docker images (alpine runtime)</li> <li><code>scripts/func-test.sh</code> (local images functional E2E)</li> <li><code>scripts/func-test-zip.sh</code> (release ZIP functional E2E)</li> </ul>"},{"location":"how-to/local-ci/#pre-push-hook-optional","title":"Pre-push hook (optional)","text":"<p>Install a Git pre-push hook to automatically run unit + functional tests before pushing:</p> <pre><code>scripts/install-git-hooks.sh\n</code></pre> <p>On every <code>git push</code>, the hook runs:</p> <ul> <li><code>go test ./...</code></li> <li><code>scripts/func-test.sh</code></li> </ul> <p>If Docker is not available, it skips the functional test.</p>"},{"location":"how-to/local-ci/#run-the-exact-ci-workflow-locally-optional","title":"Run the exact CI workflow locally (optional)","text":"<p>You can use <code>act</code> (https://github.com/nektos/act) to run GitHub Actions locally:</p> <pre><code>act -j functional-test\nact -j functional-test-zip\n</code></pre> <p>Note: you may need to set up a compatible Docker runner image and install <code>jq</code>, <code>curl</code>, and <code>unzip</code> inside it.</p>"},{"location":"how-to/local-dev-stack/","title":"Local dev stack","text":"<p>This repository includes a helper script to run a complete local stack:</p> <ul> <li>License server (Ed25519 keys, issue/verify/revoke)</li> <li>Veilgate gateway (with license verification enabled)</li> <li>Demo upstream service</li> </ul>"},{"location":"how-to/local-dev-stack/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and docker compose</li> <li><code>curl</code> and <code>jq</code> on the host</li> </ul>"},{"location":"how-to/local-dev-stack/#start-the-stack","title":"Start the stack","text":"<p>From the repo root:</p> <pre><code>scripts/run-local-stack.sh\n</code></pre> <p>What it does:</p> <ul> <li>Builds images for <code>license-server</code>, <code>demo-upstream</code> and <code>veilgate</code></li> <li>Starts the license server on <code>localhost:9400</code></li> <li>Fetches the public key and issues a development license</li> <li>Writes <code>.env.license</code> with <code>VEILGATE_LICENSE_PUBKEY_B64</code></li> <li>Generates <code>dist/local/config.yaml</code> by injecting the license token</li> <li>Starts <code>demo-upstream</code> and <code>veilgate</code> with the generated config</li> </ul> <p>Test calls:</p> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>License server endpoints:</p> <ul> <li><code>http://localhost:9400/pubkey</code></li> <li><code>POST http://localhost:9400/issue</code> (requires <code>LICENSE_ADMIN_TOKEN</code>, default <code>dev-admin-token</code>)</li> <li><code>POST http://localhost:9400/verify</code></li> <li><code>POST http://localhost:9400/revoke</code> (admin)</li> <li><code>http://localhost:9400/crl</code></li> </ul> <p>Admin portal:</p> <ul> <li>URL: <code>http://localhost:9400/portal</code></li> <li>Default user (dev): <code>admin</code> / <code>dev-portal-pass</code></li> </ul>"},{"location":"how-to/local-dev-stack/#customizing","title":"Customizing","text":"<p>Environment variables recognized by the script:</p> <ul> <li><code>ADMIN_TOKEN</code> \u2013 admin bearer for issuing licenses (default <code>dev-admin-token</code>)</li> <li><code>LICENSE_SUBJECT</code> \u2013 subject shown in issued licenses (default <code>Local Dev</code>)</li> <li><code>MAX_UPSTREAMS</code> / <code>MAX_ROUTES</code> \u2013 entitlements</li> <li><code>EXPIRES_DAYS</code> \u2013 validity period</li> <li><code>INSTANCE_ID</code> \u2013 binds the license to this gateway instance id</li> </ul>"},{"location":"how-to/migrating-from-tyk/","title":"Migrating from Tyk","text":"<p>This guide helps you migrate existing Tyk Gateway configurations to Veilgate, covering the automated migration tool and manual configuration adjustments.</p>"},{"location":"how-to/migrating-from-tyk/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to your Tyk API definition files (<code>apis/*.json</code>)</li> <li>Optional: CORS configuration files (<code>config/cors-*.json</code>)</li> <li>Go 1.21+ installed (for running the migration tool)</li> <li>Understanding of your current Tyk setup</li> </ul>"},{"location":"how-to/migrating-from-tyk/#quick-migration","title":"Quick migration","text":""},{"location":"how-to/migrating-from-tyk/#step-1-run-the-migration-tool","title":"Step 1: Run the migration tool","text":"<p>Veilgate includes an automated migration tool that converts Tyk API definitions to Veilgate format:</p> <pre><code># From the Veilgate repository root\ngo run ./scripts/tyk-to-veilgate/convert.go \\\n  -apis=/path/to/tyk/apis \\\n  -cors=/path/to/tyk/config \\\n  -output=./veilgate.yaml\n</code></pre> <p>The tool outputs warnings for features that require manual attention.</p>"},{"location":"how-to/migrating-from-tyk/#step-2-review-the-generated-configuration","title":"Step 2: Review the generated configuration","text":"<p>Open the generated <code>veilgate.yaml</code> and verify:</p> <ul> <li>Routes: Ensure paths and methods match your expectations</li> <li>Upstreams: Verify backend URLs are correct</li> <li>Authentication: Configure secrets for API keys and JWT issuers</li> <li>Rate limits: Adjust values based on your traffic patterns</li> </ul>"},{"location":"how-to/migrating-from-tyk/#step-3-add-secrets","title":"Step 3: Add secrets","text":"<p>The migration tool does not copy secrets. Add them manually:</p> <pre><code>security:\n  api_keys:\n    - id: mobile-app\n      key: \"your-secret-key-here\"\n      label: \"Mobile Application\"\n  jwt_issuers:\n    - id: main-idp\n      algorithm: JWKS\n      jwks_url: \"https://auth.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#step-4-test-the-configuration","title":"Step 4: Test the configuration","text":"<pre><code># Validate the configuration\n./veilgate validate-config -config=./veilgate.yaml\n\n# Start in development mode\n./veilgate serve -config=./veilgate.yaml\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#feature-mapping-reference","title":"Feature mapping reference","text":""},{"location":"how-to/migrating-from-tyk/#listen_path-and-strip_listen_path","title":"listen_path and strip_listen_path","text":"<p>Tyk:</p> <pre><code>{\n  \"proxy\": {\n    \"listen_path\": \"/ext/orders/\",\n    \"strip_listen_path\": true,\n    \"target_url\": \"http://orders:8080/api/v1\"\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: orders\n    path: /ext/orders/*\n    upstream_id: orders-upstream\n    rewrite:\n      strip_prefix: /ext/orders\n      add_prefix: /api/v1\n\nupstreams:\n  - id: orders-upstream\n    endpoints:\n      - url: http://orders:8080\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#cors-configuration","title":"CORS configuration","text":"<p>Tyk (inline):</p> <pre><code>{\n  \"CORS\": {\n    \"enable\": true,\n    \"allowed_origins\": [\"https://app.example.com\"],\n    \"allowed_methods\": [\"GET\", \"POST\"],\n    \"allowed_headers\": [\"*\"],\n    \"allow_credentials\": true,\n    \"max_age\": 24\n  }\n}\n</code></pre> <p>Tyk (separate file <code>config/cors-orders.json</code>):</p> <pre><code>{\n  \"enable\": true,\n  \"allowed_origins\": [\"https://app.example.com\"]\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: orders\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n      allowed_methods:\n        - GET\n        - POST\n      allowed_headers:\n        - \"*\"\n      allow_credentials: true\n      max_age: 24\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#response-headers","title":"Response headers","text":"<p>Tyk:</p> <pre><code>{\n  \"global_response_headers\": {\n    \"Strict-Transport-Security\": \"max-age=31536000\",\n    \"X-Content-Type-Options\": \"nosniff\"\n  },\n  \"global_response_headers_remove\": [\"Server\", \"X-Powered-By\"]\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: api\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000\"\n        X-Content-Type-Options: nosniff\n      remove:\n        - Server\n        - X-Powered-By\n</code></pre> <p>For global headers, use <code>server.response_headers</code>:</p> <pre><code>server:\n  response_headers:\n    add:\n      Strict-Transport-Security: \"max-age=31536000\"\n    remove:\n      - Server\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#jwt-authentication-jwks","title":"JWT authentication (JWKS)","text":"<p>Tyk:</p> <pre><code>{\n  \"use_keyless_access\": false,\n  \"jwt_signing_method\": \"RSA\",\n  \"jwt_source\": \"https://auth.example.com/.well-known/jwks.json\",\n  \"jwt_identity_base_field\": \"sub\"\n}\n</code></pre> <p>Veilgate:</p> <pre><code>security:\n  jwt_issuers:\n    - id: main-idp\n      algorithm: JWKS\n      jwks_url: https://auth.example.com/.well-known/jwks.json\n      jwks_cache_ttl_seconds: 300\n      audience:\n        - your-app\n\nroutes:\n  - id: protected-api\n    auth:\n      jwt_issuer_id: main-idp\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#api-key-authentication","title":"API key authentication","text":"<p>Tyk:</p> <pre><code>{\n  \"use_standard_auth\": true,\n  \"auth\": {\n    \"auth_header_name\": \"Api-key\"\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: service-a\n      key: \"secret-key\"\n\nroutes:\n  - id: internal-api\n    auth:\n      api_key: true\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#rate-limiting","title":"Rate limiting","text":"<p>Tyk:</p> <pre><code>{\n  \"disable_rate_limit\": false,\n  \"global_rate_limit\": {\n    \"rate\": 1000,\n    \"per\": 60\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: api\n    rate_limit:\n      enabled: true\n      requests_per_second: 16.67  # 1000/60\n      burst: 50\n      scope: ip\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#proxy-options","title":"Proxy options","text":"<p>Tyk:</p> <pre><code>{\n  \"proxy\": {\n    \"preserve_host_header\": true,\n    \"transport\": {\n      \"ssl_insecure_skip_verify\": true\n    }\n  }\n}\n</code></pre> <p>Veilgate:</p> <pre><code>routes:\n  - id: legacy-api\n    proxy:\n      preserve_host_header: true\n      tls:\n        insecure_skip_verify: true\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#features-not-supported","title":"Features not supported","text":"<p>The following Tyk features are not available in Veilgate:</p> Feature Alternative Go plugins Move logic to external services JSVM virtual endpoints Use dedicated microservices GraphQL schemas Use a dedicated GraphQL gateway Quota policies Use external quota management OAuth2 token generation Use a dedicated identity provider Custom middleware chains Use Veilgate's built-in middleware"},{"location":"how-to/migrating-from-tyk/#dashboard-migration","title":"Dashboard migration","text":"<p>After migrating your API definitions, use the Veilgate dashboard to:</p> <ol> <li>View routes: Navigate to Routes view to see all migrated routes</li> <li>Edit configurations: Use the route editor for CORS, headers, and caching</li> <li>Manage API keys: Generate and manage keys in the Policies view</li> <li>Monitor traffic: Check statistics in the Overview and route details</li> </ol> <p>Access the dashboard at <code>http://localhost:9090/dashboard</code> (admin port).</p>"},{"location":"how-to/migrating-from-tyk/#testing-the-migration","title":"Testing the migration","text":""},{"location":"how-to/migrating-from-tyk/#health-checks","title":"Health checks","text":"<pre><code># Check gateway health\ncurl http://localhost:8080/healthz\n\n# Check admin health\ncurl http://localhost:9090/healthz\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#verify-routes","title":"Verify routes","text":"<pre><code># List all routes via admin API\ncurl http://localhost:9090/admin/routes | jq\n\n# Test a specific endpoint\ncurl -H \"Api-key: your-key\" http://localhost:8080/ext/orders/\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#compare-responses","title":"Compare responses","text":"<p>Test equivalent requests against both Tyk and Veilgate to verify behavior:</p> <pre><code># Against Tyk\ncurl -v https://tyk-gateway/ext/orders/123\n\n# Against Veilgate\ncurl -v http://localhost:8080/ext/orders/123\n</code></pre>"},{"location":"how-to/migrating-from-tyk/#rollback-plan","title":"Rollback plan","text":"<p>If issues arise, you can run Tyk and Veilgate in parallel:</p> <ol> <li>Keep Tyk running on its original ports</li> <li>Run Veilgate on different ports (e.g., 8081, 9091)</li> <li>Use a load balancer to gradually shift traffic</li> <li>Monitor error rates and latency</li> <li>Complete migration once confident</li> </ol>"},{"location":"how-to/migrating-from-tyk/#getting-help","title":"Getting help","text":"<ul> <li>Review the configuration reference</li> <li>Check the admin API documentation</li> <li>Open an issue on GitHub for specific migration challenges</li> </ul>"},{"location":"how-to/quickstart-docker-compose/","title":"Quickstart \u2013 Docker + docker-compose","text":""},{"location":"how-to/quickstart-docker-compose/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"how-to/quickstart-docker-compose/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart (bundled in the release).</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>security.api_keys_header_name</code> \u2013 global header carrying API keys   (defaults to <code>X-API-Key</code>, but you can switch to <code>Api-key</code> to match legacy Tyk clients),</li> <li><code>security.jwt_issuers</code> \u2013 JWT providers; set <code>algorithm: JWKS</code> and a <code>jwks_url</code>   when you want Veilgate to discover RS256 signing keys automatically,</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul> <p>For example, to mirror the Tyk setup where clients send <code>Api-key</code> and JWTs come from an IdP that exposes JWKS metadata:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: demo\n      key: demo-secret-key\n  jwt_issuers:\n    - id: accounts\n      issuer: \"https://id.example.com/\"\n      audience: [\"mobile-app\"]\n      algorithm: JWKS\n      jwks_url: \"https://id.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre> <p>Every route with <code>auth.api_key: true</code> now expects <code>Api-key: demo-secret-key</code>. Routes referencing the <code>accounts</code> issuer validate RS256 tokens by downloading and caching signing keys from the JWKS URL. See the configuration reference for the complete set of fields and validation rules.</p>"},{"location":"how-to/quickstart-docker-compose/#adding-an-mcp-server-to-the-demo-stack","title":"Adding an MCP server to the demo stack","text":"<p>Once you have designed MCP tools in the dashboard (MCP Tools \u2192 Design tools), you can export a ready-to-run MCP server as a ZIP archive:</p> <ol> <li>Open MCP Tools in the dashboard and ensure you have at least one MCP    tool configured (for example, for the demo <code>items</code> API).</li> <li>Switch to the Export MCP server tab.</li> <li>Choose the tools to include, set a server name (e.g. <code>items-api-mcp</code>) and    download the ZIP.</li> <li>Unpack the ZIP next to your <code>docker-compose.yml</code> or in a separate repo and    build the MCP server:</li> </ol> <pre><code>unzip items-api-mcp.zip -d ./items-api-mcp\ncd items-api-mcp/mcp/items-api-mcp\ngo build ./...\n</code></pre> <p>You can now run the MCP server alongside Veilgate (for example using a separate Dockerfile and service in <code>docker-compose.yml</code>) and configure your MCP-compatible client to talk to this new binary while all HTTP traffic still flows through Veilgate.</p>"},{"location":"how-to/quickstart-docker-compose/#initial-admin-user-dashboard-login","title":"Initial admin user &amp; dashboard login","text":"<p>To use the built\u2011in dashboard for managing routes, APIs and API keys, you need an admin user. There are two recommended ways to bootstrap it:</p> <ol> <li>Via configuration file (hash only, no plaintext):</li> </ol> <p>In <code>config/veilgate.yaml</code> add:</p> <p><code>yaml    admin_auth:      store_path: ./data/admin-users.db         # optional, default: ./data/admin-users.db      seed_admin_user: admin                    # user name      seed_admin_password_hash: \"&lt;bcrypt-hash&gt;\" # bcrypt hash of the initial password</code></p> <p>On first start, if no admin users exist yet, Veilgate creates this user and    stores it in a small embedded database at <code>store_path</code>.</p> <ol> <li>Via environment variables (convenient for local/docker\u2011compose dev):</li> </ol> <p>Instead of hard\u2011coding the password hash in YAML, you can seed the first    admin user from environment variables. For example, in your    <code>docker-compose.yml</code>:</p> <p><code>yaml    services:      veilgate:        environment:          VEILGATE_DEV_ADMIN_USER: admin          VEILGATE_DEV_ADMIN_PASSWORD: admin          VEILGATE_ADMIN_SESSION_SECRET: \"change-me-long-random\"</code></p> <p>On first start, if the admin store is empty:</p> <ul> <li><code>VEILGATE_DEV_ADMIN_USER</code> and <code>VEILGATE_DEV_ADMIN_PASSWORD</code> are used to      create an <code>admin</code> user,</li> <li>the password is hashed with bcrypt at startup; only the hash is stored      on disk.</li> </ul> <p>After bootstrapping, visit <code>http://localhost:9090/dashboard</code> and log in with the admin credentials you configured above.</p>"},{"location":"how-to/quickstart-docker-compose/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"how-to/quickstart-docker-compose/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p>```bash curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</p>"},{"location":"how-to/quickstart-docker-compose/#or-if-you-switched-to-api-key","title":"\u2026or, if you switched to Api-key:","text":"<p>curl -H 'Api-key: demo-secret-key' http://localhost:8080/    ```</p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"how-to/quickstart-docker-compose/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"how-to/quickstart-docker-compose/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"overview/","title":"Veilgate \u2013 overview","text":"<p>Veilgate is a single-binary, high\u2011performance HTTP API gateway with:</p> <ul> <li>Gateway \u2013 configurable reverse proxy with routing, auth, rate limiting and DDoS guardrails.</li> <li>Admin server &amp; dashboard \u2013 JSON admin API plus a built\u2011in React dashboard for operators.</li> <li>MCP integration \u2013 first\u2011class support for exposing HTTP APIs as MCP tools for LLM agents.</li> </ul> <p>Veilgate focuses on:</p> <ul> <li>Performance \u2013 low additional latency vs talking directly to upstreams.</li> <li>Simplicity \u2013 configuration\u2011first, minimal moving parts.</li> <li>Extensibility \u2013 composable middleware, policies and MCP tools.</li> <li>Operability \u2013 metrics, health checks, rich admin API and dashboard.</li> </ul> <p>For a deeper architectural walkthrough, see:</p> <ul> <li>Core concepts</li> <li>How\u2011to guides</li> <li>Reference</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section contains detailed reference material:</p> <ul> <li>Configuration reference \u2013 structure of <code>veilgate.yaml</code>.</li> <li>Admin API \u2013 OpenAPI-backed reference for the admin server.</li> <li>MCP configuration \u2013 how to define MCP tools and mappings.</li> <li>CLI commands \u2013 <code>veilgate</code> commands and flags.</li> <li>Performance \u2013 benchmarking and performance tuning guide.</li> <li>Changelog &amp; Conventional Commits \u2013 how changelog generation and commit conventions work.</li> </ul>"},{"location":"reference/admin-api/","title":"Admin API","text":"<p>The admin server exposes a JSON API for operators under a dedicated listener.</p> <p>Endpoints include:</p> <ul> <li><code>GET /healthz</code> \u2013 basic liveness probe.</li> <li><code>GET /readyz</code> \u2013 readiness probe.</li> <li><code>GET /metrics</code> \u2013 Prometheus metrics.</li> <li><code>POST /admin/auth/login</code> \u2013 authenticate an admin user and establish a session (HTTP-only cookie).</li> <li><code>POST /admin/auth/logout</code> \u2013 terminate the current admin session.</li> <li><code>GET /admin/routes</code> \u2013 effective routes and their configuration.</li> <li><code>POST /admin/routes</code> \u2013 create a new route and apply it at runtime.</li> <li><code>PUT /admin/routes/{id}</code> \u2013 update an existing route.</li> <li><code>DELETE /admin/routes/{id}</code> \u2013 delete an existing route.</li> <li><code>GET /admin/upstreams</code> \u2013 upstream pools and health.</li> <li><code>GET /admin/policies</code> \u2013 auth and rate\u2011limit policies.</li> <li><code>PUT /admin/policies</code> \u2013 update security and rate\u2011limit policies.</li> <li><code>GET /admin/mcp/tools</code> \u2013 MCP tools and mappings (once configured).</li> <li><code>GET /admin/summary</code> \u2013 basic gateway summary (total routes and upstreams).</li> <li><code>GET /admin/stats/routes</code> \u2013 basic usage statistics per route (requests, errors, latency).</li> <li><code>GET /admin/stats/api-keys</code> \u2013 basic usage statistics per API key.</li> <li><code>GET /admin/stats/security</code> \u2013 aggregated auth failures and rate-limit rejections per route.</li> </ul> <p>The full, structured definition of the admin API is generated as an OpenAPI document and published in the external documentation site.</p> <p>Most <code>/admin/*</code> endpoints (including the dashboard under <code>/dashboard</code>) require a valid admin session and are rate-limited per client IP to protect against abuse. Errors are returned as JSON objects of the form:</p> <pre><code>{ \"error\": \"human readable message\" }\n</code></pre>"},{"location":"reference/changelog/","title":"Changelog &amp; Conventional Commits","text":"<p>Veilgate uses an automated changelog generated from git history using the Conventional Commits convention. The CI release workflow reads commits between versions and updates <code>CHANGELOG.md</code> and GitHub Releases automatically.</p>"},{"location":"reference/changelog/#conventional-commits-in-veilgate","title":"Conventional Commits in Veilgate","text":"<p>Commit messages SHOULD follow this shape:</p> <pre><code>type(scope): short description\n</code></pre> <p>Where:</p> <ul> <li><code>type</code> is one of:</li> <li><code>feat</code> \u2013 new user-facing feature.</li> <li><code>fix</code> \u2013 bug fix.</li> <li><code>perf</code> \u2013 performance improvements.</li> <li><code>refactor</code> \u2013 internal refactors that are not features or fixes.</li> <li><code>docs</code> \u2013 documentation-only changes.</li> <li><code>test</code> \u2013 tests only.</li> <li><code>build</code> \u2013 build tooling, dependencies.</li> <li><code>ci</code> \u2013 CI configuration, workflows.</li> <li><code>chore</code> \u2013 maintenance, small internal tweaks.</li> <li><code>revert</code> \u2013 reverting a previous commit.</li> <li><code>scope</code> is optional and indicates the main area, e.g. <code>router</code>, <code>admin-api</code>,   <code>dashboard</code>, <code>mcp</code>, <code>release</code>, <code>docs</code>.</li> </ul> <p>Examples:</p> <pre><code>feat(router): add host-based routing support\nfix(ratelimit): avoid nil dereference when config is missing\ndocs: describe MCP tools in configuration reference\nci(release): make checkout fetch full history\n</code></pre>"},{"location":"reference/changelog/#breaking-changes","title":"Breaking changes","text":"<p>Breaking changes SHOULD be marked using one of:</p> <ul> <li>A <code>!</code> after the type or scope:</li> </ul> <p><code>text   feat!: remove deprecated gateway flags   refactor(router)!: change default path matching semantics</code></p> <ul> <li>Or a <code>BREAKING CHANGE:</code> footer in the commit body:</li> </ul> <p>```text   feat(auth): switch default JWT algorithm to RS256</p> <p>BREAKING CHANGE: HS256 tokens are no longer accepted by default; config must be updated.   ```</p> <p>The changelog generator detects <code>!</code> and <code>BREAKING CHANGE:</code> and highlights these entries accordingly.</p>"},{"location":"reference/changelog/#release-commits","title":"Release commits","text":"<p>Release/version bump commits use a dedicated form so they are easy to exclude from the changelog:</p> <pre><code>chore(release): vX.Y.Z\n</code></pre> <p>These commits are created automatically by the GitHub Actions release workflow and SHOULD NOT be authored manually.</p>"},{"location":"reference/changelog/#how-the-changelog-is-generated","title":"How the changelog is generated","text":"<ul> <li>The CI workflow <code>.github/workflows/release.yml</code>:</li> <li>Bumps the <code>VERSION</code> file on pushes to <code>main</code>.</li> <li>Runs <code>scripts/gen-changelog.sh</code> to:<ul> <li>Read commits between the previous tag (e.g. <code>v0.1.7</code>) and <code>HEAD</code>.</li> <li>Group them into sections like Added, Fixed, Changed,   Performance, Docs, Tests, CI, Internal.</li> <li>Prepend a new <code>## [vX.Y.Z] - YYYY-MM-DD</code> section to <code>CHANGELOG.md</code>.</li> </ul> </li> <li> <p>Extracts the section for the current version and uses it as the body     of the GitHub Release.</p> </li> <li> <p><code>CHANGELOG.md</code> is therefore single source of truth for release notes   and is auto-generated. Manual edits will be overwritten.</p> </li> </ul>"},{"location":"reference/changelog/#local-preview","title":"Local preview","text":"<p>You can preview what the next changelog section will look like without modifying <code>CHANGELOG.md</code>:</p> <pre><code>scripts/gen-changelog.sh --from v0.1.7 --to HEAD --version 0.1.8 --preview\n</code></pre> <ul> <li><code>--from</code> should usually be the last released tag (<code>vX.Y.Z</code>).</li> <li><code>--to</code> is typically <code>HEAD</code>.</li> <li><code>--version</code> is the upcoming version number (without the leading <code>v</code>).</li> </ul> <p>This command prints the generated section to stdout instead of writing it into <code>CHANGELOG.md</code>.</p>"},{"location":"reference/cli/","title":"CLI reference","text":"<p>The <code>veilgate</code> binary exposes several subcommands:</p> <ul> <li><code>veilgate serve</code> \u2013 start the gateway and admin servers.</li> <li><code>veilgate validate-config</code> \u2013 validate the configuration file and exit.</li> <li><code>veilgate mcp init</code> \u2013 scaffold a new MCP server backed by Veilgate.</li> </ul> <p>This section will be extended as additional commands and flags are added, including the documentation export command used by the docs pipeline.</p>"},{"location":"reference/configuration/","title":"Configuration reference","text":"<p>Veilgate is configured using a YAML file, typically named <code>veilgate.yaml</code>.</p> <p>High\u2011level sections include:</p> <ul> <li><code>server</code> \u2013 listener addresses, timeouts, connection limits.</li> <li><code>admin</code> \u2013 admin/metrics/dashboard listener.</li> <li><code>logging</code> \u2013 log level, format and outputs.</li> <li><code>metrics</code> \u2013 Prometheus metrics settings.</li> <li><code>license</code> \u2013 enterprise license token and options.</li> <li><code>upstreams</code> \u2013 upstream pools and their endpoints.</li> <li><code>routes</code> \u2013 route matchers, policies and upstream references.</li> <li><code>security</code> \u2013 API keys, JWT issuers and related options.</li> <li><code>rate_limit</code> \u2013 rate limit policies and defaults.</li> <li><code>mcp</code> \u2013 MCP tool definitions and mappings (once configured).</li> <li><code>admin_auth</code> \u2013 admin users, sessions and admin API rate\u2011limits.</li> </ul> <p>See example configs under <code>examples/</code> and in release packages for concrete values.</p>"},{"location":"reference/configuration/#logging-request-correlation-ids","title":"Logging \u2013 request &amp; correlation IDs","text":"<p>Veilgate automatically ensures every incoming request carries a <code>request_id</code> for consistent debugging:</p> <ul> <li>Incoming <code>X-Request-ID</code> headers are respected; if missing, the gateway   generates a new opaque ID and returns it via the same header.</li> <li><code>X-Correlation-ID</code> headers are copied through unchanged so upstream systems   can stitch together multi-hop traces.</li> <li>Both values are stored in the request context and emitted with every structured   log entry (<code>request_id</code>, <code>correlation_id</code> fields), making it easy to filter   logs per call chain.</li> </ul> <p>Set <code>logging.access.enabled: false</code> to completely remove the access-log middleware from the hot path in high-throughput environments (fewer allocations, no per-request JSON log). When disabled, request/correlation IDs are not attached to the context, so only enable this mode if you prefer raw performance over diagnostic richness. Customise formats and levels via the rest of the <code>logging</code> section as before.</p>"},{"location":"reference/configuration/#metrics-auth-rate-limit-counters","title":"Metrics \u2013 auth &amp; rate-limit counters","text":"<p>In addition to the core HTTP metrics, Veilgate now exports dedicated security counters whenever <code>metrics</code> are enabled:</p> <ul> <li><code>veilgate_auth_failures_total{route_id,reason}</code> counts API key and JWT   failures. <code>reason</code> is either <code>api_key</code>, <code>jwt</code>, or <code>unknown</code>.</li> <li><code>veilgate_ratelimit_rejections_total{route_id,scope}</code> counts requests rejected   by rate limiting. <code>scope</code> reflects the evaluated limiter (<code>ip</code>, <code>route</code>,   <code>api_key</code>, or <code>unknown</code> when not set).</li> </ul> <p>Use these series to alert on unexpected auth errors or aggressive clients. The associated <code>/admin/stats/*</code> snapshots can be disabled via <code>metrics.detailed_stats: false</code>, which removes per-request lock contention for the in-memory counters while leaving Prometheus metrics untouched. This is recommended for latency-sensitive production or benchmark profiles.</p>"},{"location":"reference/configuration/#admin_auth-admin-users-dashboard-login","title":"<code>admin_auth</code> \u2013 admin users &amp; dashboard login","text":"<p>The optional <code>admin_auth</code> section controls how admin users are stored and how the dashboard <code>/dashboard</code> and admin API <code>/admin/*</code> are protected.</p> <p>Example:</p> <pre><code>admin_auth:\n  store_path: ./data/admin-users.db\n  seed_admin_user: admin\n  seed_admin_password_hash: \"&lt;bcrypt-hash&gt;\"\n  # or, to read plaintext from an env var and hash it at startup:\n  # seed_admin_password_env: VEILGATE_ADMIN_BOOTSTRAP_PASSWORD\n  rate_limit:\n    enabled: true\n    requests_per_second: 10\n    burst: 20\n</code></pre> <p>Key fields:</p> <ul> <li><code>store_path</code> \u2013 path to the embedded admin user database (bbolt file). If not   set, a sensible default under the process working directory is used.</li> <li><code>seed_admin_user</code> / <code>seed_admin_password_hash</code> \u2013 optional initial admin   credentials; the password must be provided as a bcrypt hash.</li> <li><code>seed_admin_password_env</code> \u2013 optional name of an environment variable holding   the plaintext password to be hashed at startup (convenient for dev/test).</li> <li><code>rate_limit</code> \u2013 basic rate limit settings for the admin API (same shape as   <code>rate_limit.default</code> used for routes).</li> </ul>"},{"location":"reference/configuration/#security-api-keys-jwt-issuers","title":"<code>security</code> \u2013 API keys &amp; JWT issuers","text":"<p>The <code>security</code> section configures shared authentication primitives that routes can reference later on:</p> <ul> <li><code>api_keys</code> \u2013 static keys defined up front (id, key, optional label/created_at).</li> <li><code>api_keys_header_name</code> \u2013 global header that carries API keys on every route.   Defaults to <code>X-API-Key</code>, but you can switch to Tyks <code>Api-key</code> or any other   canonical header without recompiling the gateway.</li> <li><code>jwt_issuers</code> \u2013 trusted JWT providers. Each issuer advertises:</li> <li><code>id</code> \u2013 unique reference used by routes (<code>routes[].auth.jwt_issuer_id</code>).</li> <li><code>algorithm</code> \u2013 <code>HS256</code>, <code>RS256</code> (local PEM), or <code>JWKS</code> for remote key sets.</li> <li>Depending on the algorithm, additional fields such as <code>hs256_secret</code>,     <code>rsa_public_key_path</code>, <code>jwks_url</code>, and <code>jwks_cache_ttl_seconds</code> are required.</li> <li>Optional <code>issuer</code> and <code>audience[]</code> constraints are enforced during token     validation.</li> </ul> <p>Routes can still override the header name on a per-route basis via <code>routes[].auth.api_key_header_name</code>. If left empty, the global header name applies.</p> <p>Example:</p> <pre><code>security:\n  api_keys_header_name: \"Api-key\"\n  api_keys:\n    - id: m2m-service\n      key: demo-secret-key\n      label: \"Internal service\"\n  jwt_issuers:\n    - id: accounts\n      issuer: \"https://id.example.com/\"\n      audience: [\"truckmanager\"]\n      algorithm: JWKS\n      jwks_url: \"https://id.example.com/.well-known/jwks.json\"\n      jwks_cache_ttl_seconds: 300\n</code></pre> <p>In the example above every route that enables <code>auth.api_key: true</code> expects the client to send <code>Api-key: demo-secret-key</code>. Any route that references the <code>accounts</code> issuer validates RS256 tokens by discovering signing keys from the JWKS URL and caching them for five minutes.</p>"},{"location":"reference/configuration/#routescache-http-response-caching","title":"<code>routes[].cache</code> \u2013 HTTP response caching","text":"<p>Veilgate provides a simple in-memory cache for idempotent requests (GET/HEAD) to reduce upstream load and improve latency. Configure caching per route:</p> <pre><code>routes:\n  - id: cached-api\n    path: /api/v1/products\n    method: GET\n    upstream_id: products-svc\n    cache:\n      enable: true\n      ttl_seconds: 300\n      vary_by_headers:\n        - Accept-Language\n        - Accept-Encoding\n      cache_all_safe_requests: false\n      honor_upstream_cache_control: true\n</code></pre> <p>Key fields:</p> <ul> <li><code>enable</code> \u2013 must be <code>true</code> to activate caching for the route.</li> <li><code>ttl_seconds</code> \u2013 how long cached responses remain valid (default is route TTL).</li> <li><code>vary_by_headers</code> \u2013 list of request headers to include in the cache key   (e.g., <code>Accept-Language</code> produces separate cache entries per language).</li> <li><code>cache_all_safe_requests</code> \u2013 when <code>true</code>, also caches OPTIONS requests.</li> <li><code>honor_upstream_cache_control</code> \u2013 when <code>true</code>, respects <code>Cache-Control: no-store</code>,   <code>Cache-Control: private</code>, and <code>max-age</code> directives from upstream responses.</li> </ul> <p>Cache metrics are exposed via Prometheus: - <code>veilgate_cache_events_total{route_id,event}</code> where <code>event</code> is <code>hit</code>, <code>miss</code>,   or <code>store</code>.</p>"},{"location":"reference/configuration/#routesproxy-proxy-and-transport-options","title":"<code>routes[].proxy</code> \u2013 Proxy and transport options","text":"<p>Each route can customize how requests are proxied to upstreams:</p> <pre><code>routes:\n  - id: legacy-api\n    path: /legacy/*\n    method: \"*\"\n    upstream_id: legacy-backend\n    proxy:\n      preserve_host_header: true\n      tls:\n        insecure_skip_verify: true\n      timeouts:\n        dial_seconds: 5\n        tls_handshake_seconds: 5\n        response_header_seconds: 30\n        expect_continue_seconds: 1\n</code></pre> <p>Key fields:</p> <ul> <li><code>preserve_host_header</code> \u2013 when <code>true</code>, the original <code>Host</code> header from the   client request is passed to the upstream (instead of the upstream's hostname).   Useful for virtual-host routing on legacy backends.</li> <li><code>tls.insecure_skip_verify</code> \u2013 skip TLS certificate verification for upstream   connections. Use only for development or trusted internal services.</li> <li><code>timeouts.dial_seconds</code> \u2013 TCP dial timeout to upstream.</li> <li><code>timeouts.tls_handshake_seconds</code> \u2013 TLS handshake timeout.</li> <li><code>timeouts.response_header_seconds</code> \u2013 time to wait for response headers.</li> <li><code>timeouts.expect_continue_seconds</code> \u2013 time to wait for 100 Continue response.</li> </ul> <p>The same <code>proxy</code> block can be specified at the upstream level (<code>upstreams[].proxy</code>) to set defaults for all routes using that upstream. Route-level settings override upstream-level settings.</p>"},{"location":"reference/configuration/#serverhttp-global-http-client-tuning","title":"<code>server.http</code> \u2013 Global HTTP client tuning","text":"<p>Global transport settings for all upstream connections:</p> <pre><code>server:\n  http:\n    max_idle_conns: 512\n    max_idle_conns_per_host: 128\n    idle_conn_timeout_seconds: 90\n    dial_timeout_seconds: 30\n    tls_handshake_timeout_seconds: 10\n    response_header_timeout_seconds: 30\n    expect_continue_timeout_seconds: 1\n</code></pre> <p>These defaults apply to all upstreams unless overridden by <code>upstreams[].proxy</code> or <code>routes[].proxy</code>.</p>"},{"location":"reference/configuration/#routesrewrite-path-rewriting","title":"<code>routes[].rewrite</code> \u2013 Path rewriting","text":"<p>Control how request paths are transformed before proxying:</p> <pre><code>routes:\n  - id: api-v2\n    path: /ext/api/v2/*\n    method: GET\n    upstream_id: api-backend\n    rewrite:\n      strip_prefix: /ext\n      add_prefix: /internal\n</code></pre> <ul> <li><code>strip_prefix</code> \u2013 removes the specified prefix from the request path before   forwarding. The prefix must match the beginning of the configured route path.</li> <li><code>add_prefix</code> \u2013 prepends the specified prefix to the (possibly stripped) path.</li> </ul> <p>Example transformation: <code>/ext/api/v2/users</code> \u2192 <code>/internal/api/v2/users</code></p>"},{"location":"reference/configuration/#routesresponse_headers-response-header-manipulation","title":"<code>routes[].response_headers</code> \u2013 Response header manipulation","text":"<p>Add or remove headers from responses:</p> <pre><code>routes:\n  - id: secure-api\n    path: /api/*\n    method: \"*\"\n    upstream_id: backend\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000; includeSubDomains\"\n        X-Content-Type-Options: nosniff\n        X-Frame-Options: DENY\n      remove:\n        - Server\n        - X-Powered-By\n</code></pre> <p>Global response headers can be configured under <code>server.response_headers</code> and are applied before route-specific overrides.</p>"},{"location":"reference/configuration/#metricssink-stats-export-pump-alternative","title":"<code>metrics.sink</code> \u2013 Stats export (Pump alternative)","text":"<p>Export periodic stats snapshots to external stores. Currently supports JSONL file output as a lightweight alternative to Tyk Pump:</p> <pre><code>metrics:\n  enabled: true\n  sink:\n    jsonl:\n      path: /var/log/veilgate/stats.jsonl\n      interval_seconds: 60\n</code></pre> <p>Each snapshot includes: - <code>timestamp</code> \u2013 when the snapshot was taken. - <code>route_stats</code> \u2013 per-route request counts and latency. - <code>api_key_stats</code> \u2013 per-API-key usage statistics. - <code>auth_failures</code> \u2013 authentication failure counts by route and reason. - <code>rate_limit_rejections</code> \u2013 rate limit rejection counts by route and scope.</p> <p>The JSONL format (one JSON object per line) is suitable for log aggregation tools like Loki, Elasticsearch, or custom processing pipelines.</p>"},{"location":"reference/configuration/#routesip_filter-ip-based-access-control","title":"<code>routes[].ip_filter</code> \u2013 IP-based access control","text":"<p>Configure CIDR-based allow/deny lists for fine-grained IP filtering per route:</p> <pre><code>routes:\n  - id: admin-api\n    path: /admin/*\n    method: \"*\"\n    upstream_id: admin-backend\n    ip_filter:\n      allow_cidrs:\n        - 10.0.0.0/8\n        - 192.168.1.0/24\n        - 172.16.0.0/12\n      deny_cidrs:\n        - 0.0.0.0/0\n</code></pre> <p>Key fields:</p> <ul> <li><code>allow_cidrs</code> \u2013 list of CIDR ranges that are allowed to access this route.   If specified, only IPs matching these ranges can access the route.</li> <li><code>deny_cidrs</code> \u2013 list of CIDR ranges that are explicitly denied. Deny rules   are evaluated after allow rules.</li> </ul> <p>Evaluation order:</p> <ol> <li>If <code>allow_cidrs</code> is non-empty, the client IP must match at least one allowed CIDR.</li> <li>If <code>deny_cidrs</code> is non-empty and the client IP matches any denied CIDR, access is denied.</li> <li>If neither list is configured, all IPs are allowed.</li> </ol> <p>The middleware extracts the client IP from: 1. The first IP in the <code>X-Forwarded-For</code> header (if present) 2. The remote address from the connection</p>"},{"location":"reference/configuration/#routescors-cors-configuration","title":"<code>routes[].cors</code> \u2013 CORS configuration","text":"<p>Enable Cross-Origin Resource Sharing (CORS) for browser-based API access:</p> <pre><code>routes:\n  - id: public-api\n    path: /api/v1/*\n    method: \"*\"\n    upstream_id: api-backend\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n        - https://staging.example.com\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n        - OPTIONS\n      allowed_headers:\n        - Content-Type\n        - Authorization\n        - X-Requested-With\n      allow_credentials: true\n      max_age: 24\n</code></pre> <p>Key fields:</p> <ul> <li><code>enable</code> \u2013 must be <code>true</code> to activate CORS handling for the route.</li> <li><code>allowed_origins</code> \u2013 list of origins that are allowed to make cross-origin requests.   Use <code>*</code> for wildcard (not recommended with credentials).</li> <li><code>allowed_methods</code> \u2013 HTTP methods permitted in cross-origin requests.</li> <li><code>allowed_headers</code> \u2013 request headers that clients may include in cross-origin requests.</li> <li><code>allow_credentials</code> \u2013 whether to include credentials (cookies, auth headers) in requests.   Note: <code>allow_credentials: true</code> is incompatible with wildcard origins.</li> <li><code>max_age</code> \u2013 how long (in hours) browsers should cache preflight responses.</li> </ul> <p>Preflight handling:</p> <p>When CORS is enabled, Veilgate automatically handles <code>OPTIONS</code> preflight requests by responding with appropriate <code>Access-Control-*</code> headers without forwarding to the upstream. This reduces upstream load and improves response times.</p>"},{"location":"reference/configuration/#complete-route-configuration-example","title":"Complete route configuration example","text":"<p>Here's a complete example showing all available route options:</p> <pre><code>routes:\n  - id: orders-api-v2\n    host: api.example.com\n    path: /ext/orders/v2/*\n    method: \"*\"\n    upstream_id: orders-backend\n\n    # Path rewriting\n    rewrite:\n      strip_prefix: /ext/orders/v2\n      add_prefix: /api/orders\n\n    # CORS for browser access\n    cors:\n      enable: true\n      allowed_origins:\n        - https://app.example.com\n      allowed_methods:\n        - GET\n        - POST\n        - PUT\n        - DELETE\n      allowed_headers:\n        - \"*\"\n      allow_credentials: false\n      max_age: 24\n\n    # Security headers\n    response_headers:\n      add:\n        Strict-Transport-Security: \"max-age=31536000; includeSubDomains\"\n        X-Content-Type-Options: nosniff\n        X-Frame-Options: DENY\n        Referrer-Policy: strict-origin-when-cross-origin\n      remove:\n        - Server\n        - X-Powered-By\n\n    # Response caching\n    cache:\n      enable: true\n      ttl_seconds: 300\n      vary_by_headers:\n        - Accept-Language\n      honor_upstream_cache_control: true\n\n    # Proxy options\n    proxy:\n      preserve_host_header: false\n      tls:\n        insecure_skip_verify: false\n      timeouts:\n        dial_seconds: 5\n        response_header_seconds: 30\n\n    # IP filtering\n    ip_filter:\n      allow_cidrs:\n        - 10.0.0.0/8\n\n    # Authentication\n    auth:\n      api_key: true\n      jwt_issuer_id: main-idp\n\n    # Rate limiting\n    rate_limit:\n      enabled: true\n      requests_per_second: 100\n      burst: 200\n      scope: api_key\n</code></pre>"},{"location":"reference/configuration/#license-enterprise-licensing","title":"<code>license</code> \u2013 enterprise licensing","text":"<p>Veilgate enforces basic demo limits when no valid license is provided:</p> <ul> <li>Upstreams: max 1</li> <li>Routes: max 3</li> </ul> <p>To enable full features, paste the issued license token:</p> <pre><code>license:\n  key: \"VEIL-1.&lt;base64url-payload&gt;.&lt;base64url-signature&gt;\"\n  # optional instance binding and future online checks\n  instance_id: \"prod-gw-eu-1\"\n  server_url: \"https://licenses.example.com\"  # optional\n</code></pre> <p>Licenses are Ed25519-signed tokens that encode entitlements such as <code>max_upstreams</code> and <code>max_routes</code>, optional expiry, and optional bindings (<code>instance_id</code>, <code>domains[]</code>).</p>"},{"location":"reference/mcp/","title":"MCP configuration","text":"<p>MCP (Model Context Protocol) support in Veilgate is driven by configuration.</p> <p>At a high level, MCP configuration describes:</p> <ul> <li>tools exposed to LLM agents,</li> <li>mappings from tools to gateway routes / HTTP endpoints,</li> <li>JSON schemas for tool inputs and outputs.</li> </ul>"},{"location":"reference/mcp/#mcp-section-in-gatewayconfig","title":"MCP section in <code>GatewayConfig</code>","text":"<p>MCP tools are configured under the top-level <code>mcp</code> section of <code>GatewayConfig</code>.</p> <p>Each tool is represented by a flat structure that intentionally mirrors Veilgate routes instead of introducing a separate policy system.</p>"},{"location":"reference/mcp/#schema","title":"Schema","text":"<p>In Go types (see <code>internal/config/types.go</code>):</p> <pre><code>type MCPConfig struct {\n    Tools []MCPToolSpec `yaml:\"tools,omitempty\" json:\"tools,omitempty\"`\n}\n\ntype MCPToolSpec struct {\n    Name        string `yaml:\"name\" json:\"name\"`\n    Description string `yaml:\"description,omitempty\" json:\"description,omitempty\"`\n    RouteID     string `yaml:\"route_id,omitempty\" json:\"route_id,omitempty\"`\n    Method      string `yaml:\"method,omitempty\" json:\"method,omitempty\"`\n    Path        string `yaml:\"path,omitempty\" json:\"path,omitempty\"`\n}\n</code></pre> <ul> <li><code>name</code> \u2013 required, MCP tool identifier (must be unique across tools),</li> <li><code>description</code> \u2013 optional, human-readable description,</li> <li><code>route_id</code> \u2013 optional link to an existing <code>routes[].id</code> in <code>GatewayConfig</code>,</li> <li><code>method</code> \u2013 optional HTTP method (e.g. <code>GET</code>, <code>POST</code>),</li> <li><code>path</code> \u2013 optional HTTP path (e.g. <code>/users/{id}</code>).</li> </ul> <p>Validation rules (see <code>internal/config/validate.go</code>):</p> <ul> <li>every tool must have <code>name</code>,</li> <li>tool names must be unique,</li> <li>if <code>route_id</code> is provided, it must point at a route defined in <code>routes</code>.</li> </ul>"},{"location":"reference/mcp/#minimal-example","title":"Minimal example","text":"<pre><code>server:\n  listen_address: \"0.0.0.0:8080\"\nadmin:\n  listen_address: \"0.0.0.0:9090\"\nlogging:\n  level: \"info\"\nmetrics:\n  enabled: true\n\nupstreams:\n  - id: \"example-api\"\n    endpoints:\n      - url: \"http://example.com\"\n\nroutes:\n  - id: \"example-route\"\n    path: \"/example\"\n    method: \"GET\"\n    upstream_id: \"example-api\"\n\nmcp:\n  tools:\n    - name: \"example_route_tool\"\n      description: \"Call the /example route via Veilgate.\"\n      route_id: \"example-route\"\n      method: \"GET\"\n      path: \"/example\"\n</code></pre> <p>This configuration defines a single MCP tool <code>example_route_tool</code> which is logically coupled to the <code>example-route</code> route.</p>"},{"location":"reference/mcp/#admin-api-adminmcptools","title":"Admin API: <code>/admin/mcp/tools</code>","text":"<p>The admin API exposes the current MCP tools and supports basic CRUD via:</p> <pre><code>GET /admin/mcp/tools\nPOST /admin/mcp/tools\nPUT  /admin/mcp/tools/{name}\nDELETE /admin/mcp/tools/{name}\n</code></pre> <p><code>GET /admin/mcp/tools</code> returns a JSON array of objects matching <code>MCPToolSpec</code>:</p> <pre><code>[\n  {\n    \"name\": \"example_route_tool\",\n    \"description\": \"Call the /example route via Veilgate.\",\n    \"route_id\": \"example-route\",\n    \"method\": \"GET\",\n    \"path\": \"/example\"\n  }\n]\n</code></pre> <p>This endpoint:</p> <ul> <li>is protected by admin auth and rate limiting, like the other <code>/admin/*</code> APIs,</li> <li>is consumed by the dashboard MCP view,</li> <li>should not expose secrets (it only reflects tool metadata).</li> </ul>"},{"location":"reference/mcp/#dashboard-integration","title":"Dashboard integration","text":"<p>The built-in dashboard includes:</p> <ul> <li>an MCP tools view listing tools from <code>/admin/mcp/tools</code> and showing:</li> <li><code>name</code> and <code>description</code>,</li> <li><code>route_id</code>,</li> <li><code>method</code> and <code>path</code>;</li> <li>an MCP config helper that generates a YAML fragment with <code>mcp.tools</code>   based on the current routes.</li> </ul> <p>The helper uses <code>/admin/routes</code> to list routes and produces a minimal config snippet such as:</p> <pre><code>mcp:\n  tools:\n    - name: \"route-one\"\n      description: \"\"\n      route_id: \"route-one\"\n      method: \"GET\"\n      path: \"/one\"\n</code></pre> <p>Operators can copy this fragment into the main Veilgate config or into a separate <code>mcp-tools.yaml</code> file and adjust names and descriptions as needed.</p> <p>The dashboard does not write or reload config files directly; it only assists with generating YAML, keeping the operational model simple and safe.</p>"},{"location":"reference/mcp/#mcp-scaffolding-via-cli","title":"MCP scaffolding via CLI","text":"<p>The <code>veilgate mcp init</code> command scaffolds a minimal MCP server project that can call APIs behind Veilgate:</p> <pre><code>veilgate mcp init -dir ./my-mcp-server -name my-mcp -desc \"My MCP server\" \\\n  -base-url http://localhost:8080 -route-id example-route\n</code></pre> <p>Scaffolding produces:</p> <ul> <li><code>main.go</code> \u2013 example MCP server using <code>internal/mcp</code>,</li> <li><code>README.md</code> \u2013 run instructions and an example MCP config snippet,</li> <li><code>mcp-tools.yaml</code> \u2013 a sample MCP configuration for Veilgate:</li> </ul> <pre><code>mcp:\n  tools:\n    - name: \"my-mcp_example\"\n      description: \"My MCP server\"\n      route_id: \"example-route\"\n      method: \"GET\"\n      path: \"/\"\n</code></pre> <p>You can merge <code>mcp-tools.yaml</code> into your main Veilgate config (or load it as an additional file, depending on your configuration tooling) and then adjust <code>route_id</code>, <code>method</code> and <code>path</code> to point at real routes.</p>"},{"location":"reference/mcp/#exporting-mcp-servers-from-the-dashboard","title":"Exporting MCP servers from the dashboard","text":"<p>In addition to manual scaffolding via CLI, you can design MCP tools in the dashboard and export a ready-to-run MCP server as a ZIP archive.</p>"},{"location":"reference/mcp/#workflow","title":"Workflow","text":"<ol> <li>Open the MCP Tools tab in the dashboard.</li> <li>Use Design tools to:</li> <li>create, edit and delete MCP tools,</li> <li>compose an \\\"API surface\\\" by selecting multiple routes and generating      tools for them.</li> <li>Switch to Export MCP server:</li> <li>choose which tools to include (by default all),</li> <li>provide MCP server name, directory inside the ZIP and base URL,</li> <li>click Download MCP server ZIP.</li> </ol> <p>The ZIP archive contains:</p> <ul> <li><code>main.go</code> \u2013 minimal MCP server using Veilgate's internal MCP library,</li> <li><code>README.md</code> \u2013 build and run instructions, plus wiring notes,</li> <li><code>mcp-tools.yaml</code> \u2013 a config snippet with the selected tools.</li> </ul> <p>You can:</p> <ul> <li>build and run the MCP server binary alongside Veilgate,</li> <li>merge <code>mcp-tools.yaml</code> into your gateway configuration,</li> <li>configure your MCP-compatible client to talk to the new MCP server.</li> </ul>"},{"location":"reference/mcp/#summary","title":"Summary","text":"<ul> <li><code>GatewayConfig.mcp.tools</code> defines a flat list of MCP tools,</li> <li><code>/admin/mcp/tools</code> exposes the effective tools to the dashboard and other   automation and supports CRUD,</li> <li><code>veilgate mcp init</code> and the dashboard's MCP server ZIP export make it easy to   bootstrap and maintain MCP integration without adding runtime complexity to   the gateway.</li> </ul>"},{"location":"reference/performance/","title":"Performance","text":"<p>Veilgate is designed to be a lightweight, high-performance API gateway with minimal overhead compared to direct backend access.</p>"},{"location":"reference/performance/#performance-goals","title":"Performance goals","text":"<p>Veilgate targets the following performance characteristics:</p> Metric Target Notes p95 latency overhead \u2264 1ms Pass-through proxy, small responses Throughput 10-20k RPS 2 vCPU, simple routes without TLS Memory footprint &lt; 50MB Base memory with typical configuration Startup time &lt; 1 second Cold start to ready <p>These targets assume: - Single gateway instance - No TLS termination at the gateway - Small response bodies (1-4 KB) - In-memory rate limiting and caching</p>"},{"location":"reference/performance/#gateway-benchmark-harness","title":"Gateway benchmark harness","text":"<p>Veilgate ships with a containerized benchmark that stands up Veilgate and Tyk side-by-side, executes k6 scenarios, and renders an HTML report under <code>benchmark/report/output/</code>.</p> <pre><code># Recommended flow \u2013 everything inside the runner container.\n./benchmark/run-container.sh --scenario full --build\n</code></pre> <p>Key properties:</p> <ul> <li>Deterministic warmups \u2013 Every scenario defines <code>warmup_duration</code> and   <code>repetitions</code> in <code>benchmark/config/scenarios.yaml</code>. The orchestrator performs a   warmup phase (metrics discarded) and then executes the scenario multiple times,   aggregating p95/p99, throughput, and error rates with per-run variance in the   report.</li> <li>Broader scenario mix \u2013 The default <code>full</code> profile covers unauthenticated,   authenticated, and rate-limited routes with longer steady-state windows to   surface queueing effects.</li> <li>System telemetry \u2013 After each steady-state run the harness captures   <code>docker stats</code> for Veilgate and Tyk, storing the snapshots under   <code>benchmark/results/&lt;run&gt;/raw/system/</code>. The HTML report links those files and   displays CPU%/Mem% inline so regressions can be tied to resource contention.</li> <li>Resource pinning \u2013 To give both gateways identical CPU budgets, export   any of the following before running the benchmark (works for both native and   containerized execution):</li> </ul> <p><code>bash   export VEILGATE_CPUS=1.0   export TYK_CPUS=1.0   export VEILGATE_CPUSET=0   export TYK_CPUSET=1</code></p> <p>The orchestrator applies these values via <code>docker update</code> immediately after   <code>docker compose up</code>, ensuring repeatable runs even on noisy hosts. - Configurable host ports \u2013 If <code>localhost:18080</code> is already taken on the   host, export <code>VEILGATE_HOST_PORT=28080</code> (or pass <code>--veilgate-port 28080</code>   directly to <code>python -m benchmark.run</code>). The compose stack and report links   automatically track the overridden port, which keeps long benchmark runs from   failing on port conflicts. The containerized runner additionally connects   itself to the compose network so the load generator talks directly to   <code>veilgate:8080</code> / <code>tyk-gateway:8080</code>, bypassing host-port hairpin proxies that   often drop connections under high RPS on Colima/Docker Desktop. Set   <code>BENCHMARK_USE_COMPOSE_NETWORK=0</code> before <code>run-container.sh</code> only if you need   the older host-port routing for debugging.</p> <p>Artifacts live under <code>benchmark/results/&lt;timestamp&gt;/</code>:</p> <ul> <li><code>raw/*.json</code> \u2013 individual k6 summaries for each gateway/scenario/run.</li> <li><code>raw/system/*.json</code> \u2013 docker stats snapshots per run.</li> <li><code>aggregated/run.json</code> \u2013 merged dataset consumed by the HTML report.</li> <li><code>sink/*.jsonl</code> \u2013 Veilgate stats sink output (if enabled) with periodic route/API key stats.</li> </ul>"},{"location":"reference/performance/#benchmark-scenarios","title":"Benchmark scenarios","text":"<p>The benchmark includes scenarios covering all Tyk-parity features:</p> <ul> <li>basic-proxy: Baseline unauthenticated throughput</li> <li>rewrite-proxy: Path rewriting (<code>strip_prefix</code>/<code>add_prefix</code>)</li> <li>cors-proxy: CORS preflight and response headers</li> <li>cache-hit: HTTP caching with hit ratio metrics</li> <li>jwt-jwks: JWT validation via JWKS</li> <li>apikey-custom: Custom API key header names</li> <li>tls-preserve-host: HTTPS upstream with host header preservation</li> <li>auth-proxy: API key authentication overhead</li> <li>ratelimit-burst: Global rate limiting</li> <li>ipfilter: CIDR-based IP filtering</li> <li>ratelimit-perkey: Per-API-key rate limiting</li> <li>websocket-throughput: WebSocket handshake and message throughput</li> </ul> <p>Each scenario includes functional tests (correctness) and load tests (performance). The <code>smoke</code> profile runs only <code>basic-proxy</code>; <code>ci</code> runs a subset; <code>full</code> runs all scenarios.</p>"},{"location":"reference/performance/#running-benchmarks","title":"Running benchmarks","text":"<p>For micro-level profiling (single middleware combinations, allocations, etc.) use the Go benchmarks shipped in <code>internal/perf/</code>:</p> <pre><code># Quick benchmark run\ngo test -bench=. ./internal/perf/...\n\n# Extended run with more iterations\ngo test -bench=. -benchtime=5s ./internal/perf/...\n\n# With memory allocation stats\ngo test -bench=. -benchmem ./internal/perf/...\n</code></pre>"},{"location":"reference/performance/#available-microbenchmarks","title":"Available microbenchmarks","text":"Benchmark Description <code>BenchmarkGatewayRoundTrip</code> Basic proxy pass-through <code>BenchmarkGatewayWithCORS</code> CORS middleware overhead <code>BenchmarkGatewayWithRateLimit</code> Rate limiting middleware overhead <code>BenchmarkGatewayWithCache</code> Response caching (cache hit) <code>BenchmarkGatewayWithRewrite</code> Path rewriting overhead <code>BenchmarkGatewayWithResponseHeaders</code> Response header manipulation <code>BenchmarkGatewayAllFeatures</code> All middleware combined <code>BenchmarkGatewayLargeBody</code> Large request/response handling <code>BenchmarkGatewayManyRoutes</code> Routing with 100 routes"},{"location":"reference/performance/#interpreting-results","title":"Interpreting results","text":"<p>Example output:</p> <pre><code>BenchmarkGatewayRoundTrip-4      50000     28456 ns/op    1024 B/op    12 allocs/op\n</code></pre> <ul> <li><code>50000</code> \u2013 number of iterations</li> <li><code>28456 ns/op</code> \u2013 nanoseconds per operation (~28 \u03bcs)</li> <li><code>1024 B/op</code> \u2013 bytes allocated per operation</li> <li><code>12 allocs/op</code> \u2013 heap allocations per operation</li> </ul>"},{"location":"reference/performance/#performance-tuning","title":"Performance tuning","text":""},{"location":"reference/performance/#connection-pooling","title":"Connection pooling","text":"<p>Configure HTTP transport settings for your workload:</p> <pre><code>server:\n  http:\n    max_idle_conns: 512\n    max_idle_conns_per_host: 128\n    idle_conn_timeout_seconds: 90\n</code></pre> <p>More idle connections reduce connection establishment overhead but consume memory.</p>"},{"location":"reference/performance/#rate-limiting-scope","title":"Rate limiting scope","text":"<p>Rate limiting scope affects performance:</p> <ul> <li><code>route</code> \u2013 fastest, single limiter per route</li> <li><code>ip</code> \u2013 requires IP extraction, per-IP limiters</li> <li><code>api_key</code> \u2013 requires auth context, per-key limiters</li> </ul> <p>For high-throughput routes, consider <code>route</code> scope with appropriate limits.</p>"},{"location":"reference/performance/#caching","title":"Caching","text":"<p>Enable caching for idempotent endpoints:</p> <pre><code>routes:\n  - id: products-api\n    path: /api/products/*\n    method: GET\n    upstream_id: products\n    cache:\n      enable: true\n      ttl_seconds: 300\n</code></pre> <p>Cache hits bypass the upstream entirely, providing significant latency reduction.</p>"},{"location":"reference/performance/#response-headers","title":"Response headers","text":"<p>Minimize header manipulation for latency-sensitive routes:</p> <pre><code>routes:\n  - id: latency-critical\n    path: /api/realtime/*\n    method: GET\n    upstream_id: realtime\n    # No response_headers section = no processing overhead\n</code></pre>"},{"location":"reference/performance/#comparison-with-tyk","title":"Comparison with Tyk","text":"<p>Veilgate is designed to be simpler and faster than Tyk by:</p> <ul> <li>No embedded scripting \u2013 No JSVM or Go plugins in the hot path</li> <li>No external dependencies \u2013 No Redis/Mongo required for core functionality</li> <li>Minimal middleware \u2013 Only the middleware you configure is executed</li> <li>Efficient routing \u2013 chi router with zero-allocation path matching</li> <li>Shared transports \u2013 Connection pooling shared across routes</li> </ul> <p>Typical improvements over Tyk: - 30-50% lower latency for pass-through proxy - 60-80% lower memory footprint - Faster cold starts (&lt; 1s vs 5-10s)</p>"},{"location":"reference/performance/#load-testing","title":"Load testing","text":"<p>For production capacity planning, use external load testing tools:</p>"},{"location":"reference/performance/#using-hey","title":"Using hey","text":"<pre><code># Install hey\ngo install github.com/rakyll/hey@latest\n\n# Basic load test\nhey -n 10000 -c 100 http://localhost:8080/api/health\n\n# With authentication\nhey -n 10000 -c 100 -H \"X-API-Key: your-key\" http://localhost:8080/api/data\n</code></pre>"},{"location":"reference/performance/#using-wrk","title":"Using wrk","text":"<pre><code># Basic test\nwrk -t4 -c100 -d30s http://localhost:8080/api/health\n\n# With script for POST requests\nwrk -t4 -c100 -d30s -s post.lua http://localhost:8080/api/data\n</code></pre>"},{"location":"reference/performance/#using-vegeta","title":"Using vegeta","text":"<pre><code># Create target file\necho \"GET http://localhost:8080/api/health\" | vegeta attack -rate=1000 -duration=30s | vegeta report\n</code></pre>"},{"location":"reference/performance/#profiling","title":"Profiling","text":""},{"location":"reference/performance/#cpu-profiling","title":"CPU profiling","text":"<pre><code># Enable pprof in admin server (if configured)\ngo tool pprof http://localhost:9090/debug/pprof/profile?seconds=30\n\n# From benchmark\ngo test -bench=BenchmarkGatewayRoundTrip -cpuprofile=cpu.out ./internal/perf/...\ngo tool pprof cpu.out\n</code></pre>"},{"location":"reference/performance/#memory-profiling","title":"Memory profiling","text":"<pre><code>go test -bench=BenchmarkGatewayRoundTrip -memprofile=mem.out ./internal/perf/...\ngo tool pprof mem.out\n</code></pre>"},{"location":"reference/performance/#trace","title":"Trace","text":"<pre><code>go test -bench=BenchmarkGatewayRoundTrip -trace=trace.out ./internal/perf/...\ngo tool trace trace.out\n</code></pre>"},{"location":"reference/performance/#production-monitoring","title":"Production monitoring","text":"<p>Monitor these metrics in production:</p> <ul> <li><code>veilgate_http_request_duration_seconds</code> \u2013 Request latency histogram</li> <li><code>veilgate_http_requests_total</code> \u2013 Request count by route and status</li> <li><code>veilgate_upstream_health</code> \u2013 Backend health status</li> <li><code>veilgate_ratelimit_rejections_total</code> \u2013 Rate limit events</li> <li>Process metrics (CPU, memory, goroutines)</li> </ul> <p>Set alerts for: - p99 latency exceeding SLO - High rate limit rejection rate - Upstream health degradation - Memory growth (potential leak)</p>"}]}