{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"CONTRIBUTING-DOCS/","title":"Contributing to documentation","text":"<p>This project treats the Markdown files under <code>docs/</code> as the single source of truth for product and technical documentation.</p>"},{"location":"CONTRIBUTING-DOCS/#where-to-put-things","title":"Where to put things","text":"<ul> <li><code>docs/overview/</code> \u2013 high-level product overview and positioning.</li> <li><code>docs/concepts/</code> \u2013 core concepts such as routes, upstreams, policies, admin API, MCP.</li> <li><code>docs/how-to/</code> \u2013 task-oriented guides (quickstart, securing routes, MCP, etc.).</li> <li><code>docs/reference/</code> \u2013 detailed references (configuration, admin API, MCP config, CLI).</li> </ul> <p>When adding or changing features:</p> <ol> <li>Decide which section the change belongs to.</li> <li>Add or update the relevant Markdown file(s), including frontmatter:</li> </ol> <p>```yaml</p> <p>title: Title of the page    description: One-line summary used by the docs site.</p> <p>```</p>"},{"location":"CONTRIBUTING-DOCS/#admin-api-and-generated-specs","title":"Admin API and generated specs","text":"<p>The structured definition of the admin API is generated from code, not edited by hand.</p> <ul> <li>The generator lives in <code>internal/docsgen</code>.</li> <li>The CLI entrypoint is:</li> </ul> <p><code>bash   go run ./cmd/veilgate docs export-admin-openapi \\     -out dist/docs-src/reference/admin-api.yaml \\     -version-file VERSION</code></p> <p>When adding or changing admin endpoints:</p> <ol> <li>Update the HTTP handlers in <code>internal/admin/admin.go</code>.</li> <li>Update the endpoint list in <code>internal/docsgen</code> so OpenAPI stays in sync.</li> <li>Adjust <code>docs/reference/admin-api.md</code> text if needed.</li> </ol>"},{"location":"CONTRIBUTING-DOCS/#release-and-publishing-flow","title":"Release and publishing flow","text":"<p>On release (via <code>.github/workflows/release.yml</code> + <code>scripts/release.sh</code>):</p> <ol> <li><code>scripts/release.sh</code> copies <code>docs/</code> into <code>dist/docs-src/</code> and runs the docs generator.</li> <li>The release workflow syncs <code>dist/docs-src/</code> into the <code>blackMasoon/veilgate-releases</code> repo.</li> <li>If <code>mkdocs.yml</code> exists in <code>veilgate-releases</code>, the workflow runs <code>mkdocs build</code> there.</li> </ol> <p>The MkDocs configuration and navigation live in the <code>veilgate-releases</code> repository. If you add a new page under <code>docs/</code>, remember to update the <code>mkdocs.yml</code> nav in that repo so it appears in the public documentation site.</p>"},{"location":"CONTRIBUTING-DOCS/#local-validation-optional","title":"Local validation (optional)","text":"<p>For local work you can:</p> <ul> <li>run <code>go vet ./...</code> and <code>go test ./...</code> as usual,</li> <li>run the docs generator command above to ensure OpenAPI still generates,</li> <li>run <code>mkdocs build</code> in a checkout of <code>veilgate-releases</code> to validate the full site.</li> </ul>"},{"location":"QUICKSTART/","title":"QUICKSTART","text":""},{"location":"QUICKSTART/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"QUICKSTART/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"QUICKSTART/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart.</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"QUICKSTART/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"QUICKSTART/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul>"},{"location":"QUICKSTART/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"QUICKSTART/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"QUICKSTART/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</code></p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"QUICKSTART/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"QUICKSTART/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"concepts/","title":"Core concepts","text":"<p>This section explains the core building blocks of Veilgate and how they fit together.</p> <ul> <li>Routes</li> <li>Upstreams</li> <li>Policies: auth &amp; rate limiting</li> <li>Admin API &amp; dashboard</li> <li>MCP tools</li> </ul>"},{"location":"concepts/admin-api/","title":"Admin API &amp; dashboard","text":"<p>Veilgate exposes a separate admin server for operators. It typically listens on a different port than user traffic and exposes:</p> <ul> <li>health endpoints (<code>/healthz</code>, <code>/readyz</code>),</li> <li>Prometheus metrics (<code>/metrics</code>),</li> <li>JSON admin endpoints under <code>/admin/...</code>,</li> <li>built\u2011in dashboard under <code>/dashboard</code>.</li> </ul> <p>The dashboard is a React SPA that consumes the admin JSON API to:</p> <ul> <li>display routes and their policies,</li> <li>display upstream pools and health,</li> <li>display MCP tools and their mappings (once configured),</li> <li>display summary statistics,</li> <li>manage configuration in place (when admin write access is enabled).</li> </ul>"},{"location":"concepts/admin-api/#dashboard-management-capabilities-crud","title":"Dashboard management capabilities (CRUD)","text":"<p>When the admin API is exposed with write access, the dashboard can:</p> <ul> <li>Routes</li> <li>List all effective routes (as before).</li> <li>Create new routes (<code>POST /admin/routes</code>) by filling in ID, method, host, path and upstream.</li> <li>Edit existing routes (<code>PUT /admin/routes/{id}</code>) \u2013 core routing fields can be adjusted at runtime.</li> <li>Delete routes (<code>DELETE /admin/routes/{id}</code>) \u2013 removed routes stop matching immediately.</li> <li> <p>Advanced auth and rate\u2011limit options are still primarily configured via YAML, but are validated and enforced on the updated runtime after each change.</p> </li> <li> <p>Upstreams</p> </li> <li>List upstream pools and endpoints.</li> <li>Create new upstreams (<code>POST /admin/upstreams</code>) by specifying an ID and one or more endpoint URLs.</li> <li>Edit upstream endpoints (<code>PUT /admin/upstreams/{id}</code>) \u2013 change or add/remove backend URLs.</li> <li> <p>Delete upstreams (<code>DELETE /admin/upstreams/{id}</code>); validation prevents removing upstreams still referenced by routes.</p> </li> <li> <p>API keys</p> </li> <li>View API keys defined in configuration (<code>security.api_keys</code>) as part of the policies view.</li> <li>Generate new API keys via the admin API (<code>POST /admin/security/api-keys</code>); the dashboard:<ul> <li>shows the generated key only once so it can be copied,</li> <li>updates the running configuration and key store immediately.</li> </ul> </li> <li>Activate/deactivate keys (<code>PUT /admin/security/api-keys/{id}</code>) by toggling their <code>active</code> status without removing them from history.</li> <li>Delete keys (<code>DELETE /admin/security/api-keys/{id}</code>) so they can no longer be used.</li> </ul> <p>All write operations go through the same safe flow:</p> <ol> <li>The admin server applies the change to an in\u2011memory copy of the configuration.</li> <li>The new config is validated against the same rules as the file\u2011based config.</li> <li>Runtime components (upstream registry, auth, rate limiting, router) are rebuilt.</li> <li>If everything succeeds, the new runtime is atomically swapped in; otherwise the dashboard shows a validation error and the previous config stays active.</li> </ol> <p>See the Admin API reference for endpoint\u2011level details and the write operations exposed under <code>/admin/routes</code>, <code>/admin/upstreams</code> and <code>/admin/security/api-keys</code>.</p>"},{"location":"concepts/mcp/","title":"MCP tools","text":"<p>Veilgate provides first\u2011class integration with the Model Context Protocol (MCP).</p> <p>Key ideas:</p> <ul> <li>MCP tools wrap HTTP APIs behind Veilgate and expose them to LLM agents.</li> <li>Tools have descriptors (name, description, input/output schemas).</li> <li>A tool typically maps to one or more gateway routes by ID.</li> </ul> <p>The Veilgate CLI includes scaffolding to generate an MCP server that:</p> <ul> <li>calls Veilgate via HTTP,</li> <li>uses the same auth, rate limit and observability stack as regular clients.</li> </ul> <p>See the MCP how\u2011to guides and reference for details on configuring MCP tools.</p>"},{"location":"concepts/policies/","title":"Policies: auth & rate limiting","text":"<p>title: Policies: auth &amp; rate limiting description: Built-in security and rate limiting policies and how they attach to routes.</p>"},{"location":"concepts/policies/#policies-auth-rate-limiting","title":"Policies: auth &amp; rate limiting","text":"<p>Veilgate ships with built\u2011in policies for authentication and rate limiting.</p>"},{"location":"concepts/policies/#authentication","title":"Authentication","text":"<p>Supported mechanisms:</p> <ul> <li>API keys \u2013 static keys configured in <code>security.api_keys</code>.</li> <li>JWT \u2013 HS256/RS256 tokens with configurable issuer, audience and claim constraints.</li> </ul> <p>Policies can be attached to routes to enforce:</p> <ul> <li>specific key sets,</li> <li>specific JWT issuers/audiences or claims.</li> </ul>"},{"location":"concepts/policies/#rate-limiting","title":"Rate limiting","text":"<p>Rate limiting is implemented as an efficient in\u2011memory token bucket.</p> <p>Limits can be configured per:</p> <ul> <li>API key (consumer),</li> <li>client IP,</li> <li>route.</li> </ul> <p>Policy configuration lives in the <code>rate_limit</code> section and is attached to routes via references.</p>"},{"location":"concepts/routes/","title":"Routes","text":"<p>Routes describe how Veilgate matches incoming HTTP requests and where they should be forwarded.</p> <p>Each route can match on:</p> <ul> <li>Host \u2013 HTTP <code>Host</code> header.</li> <li>Path \u2013 path prefix or pattern.</li> <li>Method \u2013 HTTP method such as <code>GET</code>, <code>POST</code>.</li> <li>Optional predicates \u2013 headers or query parameters.</li> </ul> <p>Matched routes are compiled into a Route Runtime which holds:</p> <ul> <li>upstream pool reference,</li> <li>middleware pipeline (auth, rate limiting, transforms),</li> <li>metadata (route ID, name, tags) used for metrics and observability.</li> </ul> <p>See the configuration reference for the exact YAML structure of routes.</p>"},{"location":"concepts/upstreams/","title":"Upstreams","text":"<p>Upstreams represent backend services that Veilgate proxies traffic to.</p> <p>Key ideas:</p> <ul> <li>Upstream pools \u2013 named sets of endpoints (hosts) with load\u2011balancing strategy.</li> <li>Health \u2013 each endpoint can be marked as up, degraded or down based on active/passive checks.</li> <li>Connection management \u2013 Veilgate uses tuned HTTP transports for connection pooling and timeouts.</li> </ul> <p>Routes reference upstream pools by ID, so you can:</p> <ul> <li>reuse upstreams across many routes,</li> <li>change upstream details without touching route definitions.</li> </ul>"},{"location":"how-to/","title":"How\u2011to guides","text":"<p>Start here for practical, task\u2011oriented guides:</p> <ul> <li>Quickstart: Docker + docker-compose</li> <li>(Planned) Securing routes with API keys and JWT</li> <li>(Planned) Rate limiting common scenarios</li> <li>(Planned) Exposing an API as an MCP tool</li> </ul>"},{"location":"how-to/quickstart-docker-compose/","title":"Quickstart \u2013 Docker + docker-compose","text":""},{"location":"how-to/quickstart-docker-compose/#veilgate-quickstart-docker-docker-compose","title":"Veilgate \u2013 Quickstart (Docker + docker-compose)","text":"<p>This document explains how to run a released Veilgate package using Docker and docker-compose.</p>"},{"location":"how-to/quickstart-docker-compose/#requirements","title":"Requirements","text":"<ul> <li>Docker (Desktop / Engine) installed.</li> <li>docker-compose available (either <code>docker compose</code> or the standalone   <code>docker-compose</code> binary).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#package-contents","title":"Package contents","text":"<p>After unpacking the <code>veilgate-&lt;VERSION&gt;.zip</code> archive, you should see:</p> <ul> <li><code>docker-compose.yml</code> \u2013 services for Veilgate + demo upstream.</li> <li><code>config/veilgate.yaml</code> \u2013 gateway configuration file.</li> <li><code>docs/QUICKSTART.md</code> \u2013 this quickstart (bundled in the release).</li> <li><code>VERSION</code> \u2013 release version.   (Images are pulled from a registry, e.g. GitHub Container Registry).</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#running-the-stack","title":"Running the stack","text":"<ol> <li>Unpack the archive:</li> </ol> <pre><code>unzip veilgate-&lt;VERSION&gt;.zip\ncd veilgate-&lt;VERSION&gt;\n</code></pre> <ol> <li>Start the services:</li> </ol> <pre><code>docker-compose up\n</code></pre> <p>The first run may take a while as Docker pulls or builds images.</p> <ol> <li> <p>Verify that everything works:</p> </li> <li> <p>Gateway (demo route behind the API gateway):</p> </li> </ol> <pre><code>curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/\n</code></pre> <p>You should see a JSON response from the demo upstream.</p> <ul> <li>Dashboard and admin endpoints:</li> <li><code>http://localhost:9090/dashboard</code> \u2013 built-in Veilgate dashboard.</li> <li><code>http://localhost:9090/healthz</code> \u2013 liveness endpoint.</li> <li><code>http://localhost:9090/readyz</code> \u2013 readiness endpoint.</li> <li><code>http://localhost:9090/metrics</code> \u2013 Prometheus metrics.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#configuration","title":"Configuration","text":"<p>You can change the gateway configuration in:</p> <ul> <li><code>config/veilgate.yaml</code></li> </ul> <p>Typical things you may want to adjust:</p> <ul> <li><code>upstreams</code> \u2013 addresses of your backend services,</li> <li><code>routes</code> \u2013 paths, methods and upstream assignment,</li> <li><code>security.api_keys</code> \u2013 API keys (replace <code>demo-secret-key</code> with your own),</li> <li><code>rate_limit</code> \u2013 limits per route / IP / API key.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#reloading-configuration-without-restart-hot-reload","title":"Reloading configuration without restart (hot reload)","text":"<p>Veilgate supports configuration hot reload \u2013 instead of restarting the process or container, you can reload <code>veilgate.yaml</code> on the fly. This means:</p> <ul> <li>existing connections are served to completion,</li> <li>new requests start using the new route tree and settings,</li> <li>you avoid losing metrics or logs due to process restarts.</li> </ul>"},{"location":"how-to/quickstart-docker-compose/#how-it-works-under-the-hood","title":"How it works under the hood","text":"<ul> <li>The <code>veilgate</code> process is started with:</li> </ul> <p><code>bash   veilgate serve -config /etc/veilgate/config.yaml</code></p> <ul> <li>In the container from the release package (<code>docker-compose.yml</code>), the   <code>config/veilgate.yaml</code> file from the host is mounted as:</li> </ul> <p><code>yaml   volumes:     - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro</code></p> <ul> <li>When the process receives a <code>SIGHUP</code> signal it:</li> <li>reloads the configuration file from the <code>-config</code> path,</li> <li>rebuilds from scratch:<ul> <li>the upstream registry,</li> <li>API key and JWT configuration,</li> <li>rate limit configuration,</li> <li>the HTTP router (complete route tree),</li> </ul> </li> <li>atomically swaps the HTTP handler to the new one without restarting the     server.</li> </ul> <p>If the new configuration file contains an error (e.g. a missing upstream), reload fails and the previous configuration remains active.</p>"},{"location":"how-to/quickstart-docker-compose/#hot-reload-with-docker-docker-compose","title":"Hot reload with Docker + docker-compose","text":"<p>Assume you started Veilgate using the quickstart above (with the <code>docker-compose.yml</code> from the release package) where the <code>veilgate</code> service is defined as:</p> <pre><code>services:\n  veilgate:\n    container_name: veilgate-release\n    image: ghcr.io/blackmasoon/veilgate:&lt;VERSION&gt;\n    volumes:\n      - ./config/veilgate.yaml:/etc/veilgate/config.yaml:ro\n</code></pre> <ol> <li>Modify the configuration on the host</li> </ol> <p>Update <code>config/veilgate.yaml</code> (for example, add a new route or change the    upstream):</p> <p><code>yaml    routes:      - id: example-route        path: /        method: GET        upstream_id: example-api      - id: extra-route        path: /extra        method: GET        upstream_id: example-api</code></p> <p>The file is mounted read\u2011only inside the container, but the host controls    its contents, so editing it on the host is enough.</p> <ol> <li>Send a <code>SIGHUP</code> signal to the Veilgate process in the container</li> </ol> <p>The default container name in the quickstart is <code>veilgate-release</code>, so you    can trigger a reload with:</p> <p><code>bash    docker kill -s HUP veilgate-release</code></p> <p>If you use <code>docker compose</code> without an explicit <code>container_name</code>, you can use    the service name instead:</p> <p><code>bash    docker compose kill -s HUP veilgate</code></p> <ol> <li>Verify new routes without restarting</li> </ol> <p>Existing routes should behave as before:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/</code></p> <p>New routes should be available after the hot reload:</p> <p><code>bash    curl -H 'X-API-Key: demo-secret-key' http://localhost:8080/extra</code></p>"},{"location":"how-to/quickstart-docker-compose/#when-a-full-container-restart-is-still-required","title":"When a full container restart is still required","text":"<p>Hot reload applies to logical configuration (routes, upstreams, security, rate limiting). Process-level changes still require a restart, for example when you:</p> <ul> <li>change <code>server.listen_address</code> or the admin port (<code>admin.listen_address</code>),</li> <li>upgrade the Docker image to a new Veilgate version,</li> <li>change how the process is started (<code>ENTRYPOINT</code>, flags) in   <code>docker-compose.yml</code>.</li> </ul> <p>In those cases, use a classic restart:</p> <pre><code>docker-compose down\ndocker-compose up\n</code></pre>"},{"location":"how-to/quickstart-docker-compose/#stopping-the-stack","title":"Stopping the stack","text":"<p>To stop the services:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"overview/","title":"Veilgate \u2013 overview","text":"<p>Veilgate is a single-binary, high\u2011performance HTTP API gateway with:</p> <ul> <li>Gateway \u2013 configurable reverse proxy with routing, auth, rate limiting and DDoS guardrails.</li> <li>Admin server &amp; dashboard \u2013 JSON admin API plus a built\u2011in React dashboard for operators.</li> <li>MCP integration \u2013 first\u2011class support for exposing HTTP APIs as MCP tools for LLM agents.</li> </ul> <p>Veilgate focuses on:</p> <ul> <li>Performance \u2013 low additional latency vs talking directly to upstreams.</li> <li>Simplicity \u2013 configuration\u2011first, minimal moving parts.</li> <li>Extensibility \u2013 composable middleware, policies and MCP tools.</li> <li>Operability \u2013 metrics, health checks, rich admin API and dashboard.</li> </ul> <p>For a deeper architectural walkthrough, see:</p> <ul> <li>Core concepts</li> <li>How\u2011to guides</li> <li>Reference</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section contains detailed reference material:</p> <ul> <li>Configuration reference \u2013 structure of <code>veilgate.yaml</code>.</li> <li>Admin API \u2013 OpenAPI-backed reference for the admin server.</li> <li>MCP configuration \u2013 how to define MCP tools and mappings.</li> <li>CLI commands \u2013 <code>veilgate</code> commands and flags.</li> <li>Changelog &amp; Conventional Commits \u2013 how changelog generation and commit conventions work.</li> </ul>"},{"location":"reference/admin-api/","title":"Admin API","text":"<p>The admin server exposes a JSON API for operators under a dedicated listener.</p> <p>Endpoints include:</p> <ul> <li><code>GET /healthz</code> \u2013 basic liveness probe.</li> <li><code>GET /readyz</code> \u2013 readiness probe.</li> <li><code>GET /metrics</code> \u2013 Prometheus metrics.</li> <li><code>GET /admin/routes</code> \u2013 effective routes and their configuration.</li> <li><code>POST /admin/routes</code> \u2013 create a new route and apply it at runtime.</li> <li><code>PUT /admin/routes/{id}</code> \u2013 update an existing route.</li> <li><code>DELETE /admin/routes/{id}</code> \u2013 delete an existing route.</li> <li><code>GET /admin/upstreams</code> \u2013 upstream pools and health.</li> <li><code>GET /admin/policies</code> \u2013 auth and rate\u2011limit policies.</li> <li><code>GET /admin/mcp/tools</code> \u2013 MCP tools and mappings (once configured).</li> <li><code>GET /admin/summary</code> \u2013 basic gateway summary (total routes and upstreams).</li> <li><code>GET /admin/stats/routes</code> \u2013 basic usage statistics per route (requests, errors, latency).</li> <li><code>GET /admin/stats/api-keys</code> \u2013 basic usage statistics per API key.</li> </ul> <p>The full, structured definition of the admin API is generated as an OpenAPI document and published in the external documentation site.</p>"},{"location":"reference/changelog/","title":"Changelog &amp; Conventional Commits","text":"<p>Veilgate uses an automated changelog generated from git history using the Conventional Commits convention. The CI release workflow reads commits between versions and updates <code>CHANGELOG.md</code> and GitHub Releases automatically.</p>"},{"location":"reference/changelog/#conventional-commits-in-veilgate","title":"Conventional Commits in Veilgate","text":"<p>Commit messages SHOULD follow this shape:</p> <pre><code>type(scope): short description\n</code></pre> <p>Where:</p> <ul> <li><code>type</code> is one of:</li> <li><code>feat</code> \u2013 new user-facing feature.</li> <li><code>fix</code> \u2013 bug fix.</li> <li><code>perf</code> \u2013 performance improvements.</li> <li><code>refactor</code> \u2013 internal refactors that are not features or fixes.</li> <li><code>docs</code> \u2013 documentation-only changes.</li> <li><code>test</code> \u2013 tests only.</li> <li><code>build</code> \u2013 build tooling, dependencies.</li> <li><code>ci</code> \u2013 CI configuration, workflows.</li> <li><code>chore</code> \u2013 maintenance, small internal tweaks.</li> <li><code>revert</code> \u2013 reverting a previous commit.</li> <li><code>scope</code> is optional and indicates the main area, e.g. <code>router</code>, <code>admin-api</code>,   <code>dashboard</code>, <code>mcp</code>, <code>release</code>, <code>docs</code>.</li> </ul> <p>Examples:</p> <pre><code>feat(router): add host-based routing support\nfix(ratelimit): avoid nil dereference when config is missing\ndocs: describe MCP tools in configuration reference\nci(release): make checkout fetch full history\n</code></pre>"},{"location":"reference/changelog/#breaking-changes","title":"Breaking changes","text":"<p>Breaking changes SHOULD be marked using one of:</p> <ul> <li>A <code>!</code> after the type or scope:</li> </ul> <p><code>text   feat!: remove deprecated gateway flags   refactor(router)!: change default path matching semantics</code></p> <ul> <li>Or a <code>BREAKING CHANGE:</code> footer in the commit body:</li> </ul> <p>```text   feat(auth): switch default JWT algorithm to RS256</p> <p>BREAKING CHANGE: HS256 tokens are no longer accepted by default; config must be updated.   ```</p> <p>The changelog generator detects <code>!</code> and <code>BREAKING CHANGE:</code> and highlights these entries accordingly.</p>"},{"location":"reference/changelog/#release-commits","title":"Release commits","text":"<p>Release/version bump commits use a dedicated form so they are easy to exclude from the changelog:</p> <pre><code>chore(release): vX.Y.Z\n</code></pre> <p>These commits are created automatically by the GitHub Actions release workflow and SHOULD NOT be authored manually.</p>"},{"location":"reference/changelog/#how-the-changelog-is-generated","title":"How the changelog is generated","text":"<ul> <li>The CI workflow <code>.github/workflows/release.yml</code>:</li> <li>Bumps the <code>VERSION</code> file on pushes to <code>main</code>.</li> <li>Runs <code>scripts/gen-changelog.sh</code> to:<ul> <li>Read commits between the previous tag (e.g. <code>v0.1.7</code>) and <code>HEAD</code>.</li> <li>Group them into sections like Added, Fixed, Changed,   Performance, Docs, Tests, CI, Internal.</li> <li>Prepend a new <code>## [vX.Y.Z] - YYYY-MM-DD</code> section to <code>CHANGELOG.md</code>.</li> </ul> </li> <li> <p>Extracts the section for the current version and uses it as the body     of the GitHub Release.</p> </li> <li> <p><code>CHANGELOG.md</code> is therefore single source of truth for release notes   and is auto-generated. Manual edits will be overwritten.</p> </li> </ul>"},{"location":"reference/changelog/#local-preview","title":"Local preview","text":"<p>You can preview what the next changelog section will look like without modifying <code>CHANGELOG.md</code>:</p> <pre><code>scripts/gen-changelog.sh --from v0.1.7 --to HEAD --version 0.1.8 --preview\n</code></pre> <ul> <li><code>--from</code> should usually be the last released tag (<code>vX.Y.Z</code>).</li> <li><code>--to</code> is typically <code>HEAD</code>.</li> <li><code>--version</code> is the upcoming version number (without the leading <code>v</code>).</li> </ul> <p>This command prints the generated section to stdout instead of writing it into <code>CHANGELOG.md</code>.</p>"},{"location":"reference/cli/","title":"CLI reference","text":"<p>The <code>veilgate</code> binary exposes several subcommands:</p> <ul> <li><code>veilgate serve</code> \u2013 start the gateway and admin servers.</li> <li><code>veilgate validate-config</code> \u2013 validate the configuration file and exit.</li> <li><code>veilgate mcp init</code> \u2013 scaffold a new MCP server backed by Veilgate.</li> </ul> <p>This section will be extended as additional commands and flags are added, including the documentation export command used by the docs pipeline.</p>"},{"location":"reference/configuration/","title":"Configuration reference","text":"<p>Veilgate is configured using a YAML file, typically named <code>veilgate.yaml</code>.</p> <p>High\u2011level sections include:</p> <ul> <li><code>server</code> \u2013 listener addresses, timeouts, connection limits.</li> <li><code>admin</code> \u2013 admin/metrics/dashboard listener and authentication.</li> <li><code>logging</code> \u2013 log level, format and outputs.</li> <li><code>metrics</code> \u2013 Prometheus metrics settings.</li> <li><code>upstreams</code> \u2013 upstream pools and their endpoints.</li> <li><code>routes</code> \u2013 route matchers, policies and upstream references.</li> <li><code>security</code> \u2013 API keys, JWT issuers and related options.</li> <li><code>rate_limit</code> \u2013 rate limit policies and defaults.</li> <li><code>mcp</code> \u2013 MCP tool definitions and mappings (once configured).</li> </ul> <p>See example configs under <code>examples/</code> and in release packages for concrete values.</p>"},{"location":"reference/mcp/","title":"MCP configuration","text":"<p>MCP (Model Context Protocol) support in Veilgate is driven by configuration.</p> <p>At a high level, MCP configuration describes:</p> <ul> <li>tools exposed to LLM agents,</li> <li>mappings from tools to gateway routes / HTTP endpoints,</li> <li>JSON schemas for tool inputs and outputs.</li> </ul> <p>This document will be extended once the MCP configuration model is wired into <code>GatewayConfig</code> and the admin API.</p>"}]}